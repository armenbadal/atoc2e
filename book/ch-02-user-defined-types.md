# 2 Օգտագործողի սահմանած տիպեր

_Խուճապի մի՛ մատնվեք։_

_— Դուգլաս Ադամս_

* Ներածություն
* Ստրուկտուրաներ
* Դասեր
* Միավորումներ
* Թվարկումներ
* Խորհուրդներ


## 2.1 Ներածություն

Ֆունդամենտալ (հիմնական) տիպերի (§1.4), `const` մոդիֆիկատորի (§1.6) և հայտարարման օպերատորների (§1.7) համադրումով կառուցված տիպերը կոչում ենք _ներդրված տիպեր_ (built-in types)։ C++ լեզվի ներդրված տիպերի ու գործողությունների բազմությունը բավականին հարուստ է, բայց դրանք դիտավորյալ թողնված են ցածր մակարդակում։ ?? Դրանք ուղղակիորեն և արդյունավետ արտացոլում են սովորական կոմպյուտերի ապարատային հնարավորությունները։ Այնուամենայնիվ, դրանք ծրագրավորողին չեն տրամադրում բարդ ծրագրեր գրելու համար անհրաժեշտ բարձր մակարդակի հնարավորություններ։ Փոխարենը C++ լեզուն ներդրված տիպերն ու գոծողությունները լրացնում է _աբստրակցիայի մեխանիզմների_ համապատասխան միջոցներով, որից ծրագրավորողները կարող են ստեղծել անհրաժեշտ բարձր մակարդակի միջոցները։ ??

C++ լեզվի աբստրակցիայի մեխանիզմներն առաջին հերթին մշակվել են, որպեսզի ծրագրավորողներին հնարավորություն տրվի մշակել և իրականացնել իրենց սեփական տիպերը՝ համապատասխան ներկայացմամբ և գործողություններով, և որպեսզի ծրագրավորողները կարողանան հեշտությամբ ու նրբորեն օգտագործեն այդ տիպերը։ C++ լեզվի աբստրակցիաների օգնությամբ այլ տիպերից կառուցված տիպերը կոչվում են _օգտագործողի սահմանած տիպեր_։ Այդպիսիներից են _դասերը_ և _թվարկումները_։ Օգտագործողի սահմանած տիպերը կարող են կառուցվել ինչպես ներդրված տիպերից, այնպես էլ օգտագործողի սահմանած այլ տիպերից։ Այս գրքի մեծ մասը նվիրված է օգտագործողի կողմից սահմանված տիպերի մշակմանը, իրականացմանը և օգտագործմանը։ Օգտագործողի սահմանած տիպերը հաճախ նախընտրելի են ներդրված տիպերից, քանի որ դրանց օգտագործումն ավելի պարզ է, ավելի քիչ է սխալների հնարավորությունը, և, որպես կանոն, նույքան արդյունավետ է, որքան ներդրված տիպերի օգտագործումը, միգուցե նաև ավելի արագ։ ??

Այս գլխի շարունակությունը նկարագրում է տիպերի սահմանման և օգտագործման պարզագույն և ամենահիմնարար հնարավորությունները։ [4](ch-04-classes.md)-[7](ch-07-concepts-and-generic-programming.md)-րդ գլուխները պարունակում են աբստրակցիայի մեխանիզմների և դրանցով ապահովված ծրագրավորման ոճերի առավել լրիվ նկարագրությունը։ [8](ch-08-library-and-overview.md)-[15](ch-15-concurrency.md)֊րդ գլուխները ստանդարտ գրադարանի հնարավորությունների ներածություն են, և քանի որ ստանդարտ գրադարանը հիմնականում բաղկացած է օգտագործողի սահմանած տիպերից, այդ գլուխներում բերված են օրինակներ, թե ինչ է հնարավոր կառուցել [1](ch-01-the-basics.md)-[7](ch-07-concepts-and-generic-programming.md)-րդ գլուխներում նկարագրված լեզվական միջոցների և ծրագրավորման տեխնիկաների օգտագործմամբ։ ??


## 2.2 Ստրուկտուրաներ

Հաճախ նոր տիպ կառուցելու առաջին քայլը նրան անհրաժեշտ տարրերի ընդգրկումն է տվյալների կառուցվածքի՝ ստրուկտուրայի (`struct`) մեջ.

```C++
struct Vector {
    int sz;          // տարրերի քանակը
    double* elem;    // ցուցիչ տարրերի վրա
};
```

`Vector`֊ի այս նախնական տարբերակը բաղկացած է `int` տիպի և `double*` տիպի տարրերից։

`Vector` տիպի փոփոխականը կարող է սահմանվել հետևյալ կերպ․

```C++
Vector v;
```

Այնուամենայնիվ, սրանից շատ օգուտ չկա, քանի որ `v`֊ի `elem` ցուցիչը ոչ մի բանի ցույց չի տալիս։ Որպեսզի այն օգտակար լինի, մենք պետք է `v`-ին տանք ինչ-որ տարրեր, որոնց վրա այն ցույց կտա։ Օրինակ, `Vector`֊ը մենք կարող ենք կառուցել հետևյալ ձևով․

```C++
void vector_init(Vector& v, int s)
{
    v.elem = new double[s];   // ստեղծել s հատ double տիպի թվերի զանգված
    v.sz = s;
}
```

Ահա, `v`֊ի `elem` անդամն ստանում է ցուցիչ՝ ստեղծված `new` օպերատորի կողմից և `v`֊ի `sz` անդամն ստանում է տարրերի քանակը։ `Vector&` գրառման `&`-ը ցույց է տալիս, որ `v`֊ն մենք փոխանցում ենք որպես ոչ-`const` հղում (§1.7), այդ ձևով `vector_init()` ֆունկցիան կարող է փոփոխություններ անել իրեն փոխանցված վեկտորի հետ։

`new` օպերատորը տիրույթ է առանձնացնում այն տարածքից, որը կոչվում է _ազատ տարածք_ (հայտնի է նաև որպես _դինամիկ հիշողություն_ և _heap_)։ Ազատ տարածքում տեղակայված օբյեկտներն անկախ են այն տեսանելիության տիրույթից, որտեղ ստեղծվել են և «ապրում» են, քանի դեռ չեն ոչնչացվել `delete` հրամանով (§4.2.2)։

`Vector`֊ի պարզ օգտագործումը ոկարող է ունենալ հետևյալ տեսքը․

````C++
double read_and_sum(int s)
    // կարդալ s ամբողջ թվերը cin֊ից և վերադարձնել նրանց գումարը;
    // ենթադրվում է, որ s-ը պետք է լինի դրական թիվ
{
    Vector v;
    vector_init(v,s);           // առանձնացնել s հատ տարր v-ի համար
    for (int i=0; i!=s; ++i)
        cin >> v.elem[i];       // կարդալ տարրերի մեջ

    double sum = 0;
    for (int i=0; i!=s; ++i)
        sum+=v.elem[i];       // ստանալ տարրերի գումարը
    return sum;
}
````

Գեղեցիկ և ճկուն դառնալու համար, ինչպիսին որ ստանդարտ գրադարանի `vector`֊ն է, մեր `Vector`֊ը դեռ երկար ճանապարհ պիտի անցնի։ Մասնավորապես, `Vector`-ի օգտագործողը պետք է իմանա `Vector`֊ի նկարագրության ամեն մի մանրամասնությունը։ Այս գլխի մնացած մասը և հաջորդ երկու գլուխները աստիճանաբար զարգացնում են `Vector`֊ը, որպես լեզվի հնարավորությունների և տեխնիկական հնարքների օրինակ։ [Գլուխ 11](ch-11-)-ը ներկայացնում է ստանդարտ գրադարանի `vector`֊ը, որը պարունակում է բազմաթիվ գեղեցիկ բարելավումներ։

`vector`֊ը և ստանդարտ գրադարանի մյուս բաղադրիչները ես օգտագործում եմ որպես օրինակներ, որպեսզի.
* ցուցադրեմ լեզվական հնարավորություններն ու դիզայնի տեխնիկան, և
* օգնեմ ձեզ սովորել և օգտագործել ստանդարտ գրադարանի բաղադրիչները։

Նորից մի՛ հորինեք ստանդարտ գրադարանի բաղադրիչներն, ինչպիսիք են `vector`֊ը և `string`֊ը, օգտագործեք դրանք։

Մենք `.`-ը (կետ) օգտագործում ենք `struct`֊ի անդամներին անվան (և հղման) միջոցով դիմելու համար, իսկ `->` նշանը՝ `struct`֊ի անդամներին ցուցիչով դիմելու համար։ Օրինակ․

````C++
void f(Vector v, Vector& rv, Vector* pv)
{
    int i1 = v.sz;       // դիմում անվան միջոցով
    int i2 = rv.sz;      // դիմում հղման միջոցով
    int i4 = pv->sz;     // դիմում ցուցիչի միջոցով
}
````


## 2.3 Դասեր

Տվյալների և դրանց համար սահմանված գործողությունների առանձին սահմանումն ունի իր առավելությունը, ինչպես տվյալների տարբեր եղանակով օգտագործելը։ Սակայն տվյալների ներկայացման և գործողությունների միջև ավելի սերտ կապը օգտագործողի սահմանած տիպին անհրաժեշտ է «իսկական տիպին» յուրահատուկ բոլոր հատկություններով օժտված լինելու համար։ Մասնավորապես, հաճախ ցանկանում ենք տվյալների ներկայացումն անհասանելի պահել օգտագործողներին, դրանով պարզեցնելով օգտագործումը, երաշխավորելով տվյալների անսխալ օգտագործումը, և մեզ հնարավորություն տալով հետագայում բարելավել ներկայացումը։ Դա անելու համար պետք է տարանջատենք տիպի ինտերֆեյսը (որ հասանելի է բոլորին) և նրա իրականացումը (որին մատչելի են այլ եղանակով անհասանելի տվյալները)։ Ասվածն ապահովող լեզվական մեխանիզմը կոչվում է _դաս_ (_class_)։ Դասն ունի անդամներ (members), որոնք կարող են լինել տվյալներ, ֆունկցիաներ կամ տիպեր։ Ինտերֆեյսը որոշվում է դասի `public` անդամներով, իսկ `private` անդամները հասանելի են միայն այդ ինտերֆեյսով։ Օրինակ․

````C++
class Vector {
public:
     Vector (int s) :elem{new double[s]}, sz{s} {}   //կառուցում ենք Vector֊ը
     double& operator[](int i) { return elem[i]; }   // դիմում էլեմենտին՝ ինդեքսավորում
     int size() { return sz; }
private:
     double* elem   // էլեմենտների ցուցիչը
     int sz;        // էլեմենտների քանակը
};
````

Սա ունենալով մենք կարող ենք սահմանել մեր նոր `Vector` տիպի փոփոխական.

```C++
Vector v(6);      // վեկտոր 6 տարրերով
```

`Vector` օբյեկտը գրաֆիկորեն կարող ենք ներկայացնել այսպես․

![](images/image-007.jpeg)

Պարզ ասած՝ `Vector` օբյեկտը տարրերի ցուցիչը (`elem`) և տարրերի քանակը (`sz`) պահող մի «նկարագրիչ» (handle, дескриптор) է։ Տարրերի քանակը (օրինակի մեջ 6 է) տարբեր `Vector` օբյեկտներում կարող է տարբեր լինել, իսկ նույն `Vector` օբյեկտը ժամանակի տարբեր պահերին կարող է ունենալ տարբեր քանակի տարրեր (§4.2.3)։ Սակայն ինքը `Vector` օբյեկտը միշտ նույն չափն ունի։ Սա է C++֊ում փոփոխական քանակի ինֆորմացիայի հետ աշխատելու հիմնական տեխնիկան. հաստատուն չափի նկարագրիչ, որ հղվում է «մեկ այլ տեղում» գտվող փոփոխական չափի տվյալների (օր., հիշողության դինամիկ տիրույթում՝ ընտրված `new`-ի միջոցով, §4.2.2)։ [Չորրորդ գլխի](ch-04-classes.md) հիմնական թեման է՝ թե ինչպես նախագծել և օգտագործել այդպիսի օբյեկտները։

Այստեղ `Vector`֊ի ներկայացումը (`elem` և  `sz` անդամները) հասանելի է միայն `public` անդամներով որոշված ինտերֆեյսով․ `Vector()`, `operator[]()` և `size()`։ §2.2֊ի `read_and_sum()` օրինակը պարզեցվել է այսպես․

````C++
double read_and_sum (int s)
{
    Vector v(s);                      // ստեղծվում է s հատ տարրերի վեկտոր
    for (int i=0; i!=v.size(); ++i)
        cin >> v[i];                   // կարդում ենք տարրերը

    double sum = 0;
    for (int i=0; i!=v.size(); ++i)
        sum += v[i];                     // հաշվում ենք տարրերի գումարը
    return sum;
}
````

Նույն իր դասի անունն ունեցող «ֆունկցիան» կոչվում է _կոնստրուկտոր_ (_constructor_), այն է՝ մի ֆունկցիա, որն օգտագործվում է տվյալ դասի օբյեկտները կառուցելու համար։ Այսինքն, կոնստրուկտորը՝ `Vector()`-ը, փոխարինում է  §2.2֊ի `vector_init()`֊ին։ Ի տարբերություն սովորական ֆունկցիայի, կոնստրուկտորը պարտադիր օգտագործվում է իր դասի օբյեկտներ ինիցիալիզացիայի համար։ Հետևաբար,  կոնստրուկտորի սահմամնմամբ բացառվում է դասի ոչ արժեքավորված փոփոխականների խնդիրը։

`Vector(int)`֊ը սահմանում է, թե ինչպես են կառուցվում `Vector` տիպի օբյեկտները։ Մասնավորապես, նշվում է, որ դրա համար իրեն անհրաժեշտ է ամբողջ թիվ։ Այդ ամբողջ թիվն օգտագործվում է որպես տարրերի քանակ։ Կոնստրուկտորը `Vector`֊ի անդամներն արժեքավորում է դասի անդամների արժեքավորման ցուցակն օգտագործելով․

```C++
: elem {new double[s]}, sz{s}
```

Այսինքն, նախ՝ `elem`-ն արժեքավորում ենք `s` հատ `double` տիպի տարրերի ցուցիչով՝ ընտրված հիշողության դինամիկ տիրույթից։ Ապա `sz`-ն արժեքավորում ենք `s`-ով։

Տարրերին դիմումն իրականացված է ինդեքսավորման ֆունկցիայով, որի անունն է `operator[]`: Այն վերադարձնում համապատասխան տարրի հողումը (`double&`-ը թույլատրում է ինչպես արժեքի գրելը, այնպես էլ կարդալը)։

`size()` ֆունկցիան նախատեսված է օգտագործողին տարրերի քանակը տալու համար։

Ակնհայտ է, որ սխալների մշակումն ամբողջությամբ բացակայում է, բայց մենք դրան կվերադառնանք §3.5֊ում։ Նմանապես, մենք որևէ մեխանիզմ չենք ապահովում, որը `new`-ով ձեռք բերված `double`-երի զանգվածը «կվերադարձնի» հիշողության ազատ տիրույթին. §4.2.2֊ում ցույց է տրված, թե ինչպես դեստրուկտորն օգտագործել էլեգանտ կերպով դա անելու համար։ ??

`struct`֊ի և `class`֊ի միջև ոչ մի սկզբունքային տարբերություն չկա. `struct`֊ը սովորական `class` է՝ լռելությամբ `public` անդամներով։ Օրինակ, դուք կարող եք  `struct`֊ի համար սահմանել կոնստրուկտորներ և ուրիշ անդամ֊ֆունկցիաներ։


## 2.4 Միավորումներ

`union`-ը (_միավորում_) այնպիսի մի `struct` է, որի բոլոր անդամները տեղադրված են հիշողության միևնույն հասցեից, այսինքն՝ `union`-ը զբաղեցնում է միայն իր ամենամեծ անդամի չափով տարածք։ Բնականաբար, `union`-ը միաժամանակ կարող է պահել իր միայն մեկ անդամի արժեքը։ Օրինակ, դիտարկենք սիմվոլների աղյուսակի գրառում, որը պարունակում է անուն և արժեք։ Անունը կարող է լինել կամ `Node*`, կամ էլ `int`․

````C++
enum Type { ptr, num }; // Type-ը կարող է ստանալ ptr և num արժեքները (§2.5)

struct Entry {
    string name;  // string-ը ստանդարտ գրադարանի տիպ է
    Type t;
    Node* p; // երբ t == ptr, օգտագործել p-ն
    int i;   // երբ t == num. օգտագործել i-ն
};

void f(Entry* p)
{
    if (pe−>t == num)
        cout << pe−>i;
    // ...
}
````

`p` և `i` անդամները երբեք միաժամանակ չեն օգտագործվում, հետևաբար հիշողության տարածքն անօգուտ վատնվում է։ Այդ վատնումը կարելի է հեշտությամբ վերականգնել՝ `p`-ն և `i`-ն սահմանելով որպես `union`-ի անդամներ։ Այսպես.

````C++
union Value {
    Node* p;
    int i;
};
````

Լեզուն չի հետևում, թե ինչ արժեք է գրառված միավորման մեջ, դա պետք է ծրագրավորողն անի։

```C++
struct Entry {
    string name;
    Type t;
    Value v;  // օգտագործել v.p-ն եթե t==ptr, և v.i-ն՝ եթե t==num
};

void f(Entry* pe)
{
    if (pe−>t == num)
        cout << pe−>v.i;
    // ...
}
```

_Տիպի դաշտի_ (այստեղ՝ `t`) և `union`-ում գրված տիպի համապատասխանության ապահովումը հղի է սխալներով։ Սխալներից խուսփելու համար կարող ենք այդ համապատասխանությունն ապահովել `union`-ը և տիպի դաշտը դասի մեջ ընդգրկելով, և հասանելիություն տրամադրելով միայն `union`-ը ճիշտ օգտագործող անդամ-ֆունկցիաներով։ Կիրառությունների մակարդակում այդպիսի պիտակավորված միավորումների (tagged unions) վրա հիմնված աբստրակցիաները շատ տարածված են ու կիրառելի։ «Մերկ» `union`-երի օգտագործումը ավելի լավ է հասցնել նվազագույնի։

Ստանդարտ գրադարանի `variant` տիպը կարելի է օգտագործել `union`-ների շատ ուղղակի կիրառումներ բացառելու համար։ `variant`-ը պահում է այլընտրանքային տիպերից մեկի արժեքը (§13.5.1)։ Օրինակ, `variant<Node*,int>`-ը կարող է պահել կամ `Node*`, կամ `int`։

`variant`-ի օգտագործմամբ `Entry`-ի օրինակը կարող է ունենալ այսպիսի տեսք։

```C++
struct Entry {
    string name;
    variant<Node*,int> v;
};

void f(Entry* pe)
{
    if (holds_alternative<int>(pe−>v))  // *pe-ում int արժե՞ք է (տես §13.5.1)
        cout << get<int>(pe−>v);        // վերցնել int արժեքը
    // ...
}
```

Շատ դեպքերում `variant`-ի օգտագործումն ավելի պարզ ու հուսալի է, քան `union`-ը։


## 2.5 Թվարկումներ

Ի լրումն դասերի, C++-ը տրամադրում է օգտագործողի սահմանած մի պարզ տիպ՝ արժեքների թվարկելիության հնարավորությամբ. ??

```C++
enum class Color { red, blue, green };
enum class Traffic_light { green, yellow, red };

Color col = Color::red;
Traffic_light light = Traffic_light::red;
````

Ուշադրություն դարձրեք, որ թվարկելիներն (օր., `red`) իրենց սեփական `enum class`-ի տիրույթում են, այսինքն դրանք կարող են առանց շփոթելու վտանգի կրկնվել տարբեր `enum classe`-երում։ Օրինակ, `Color::red`-ը `Color`-ի `red`-ն է, որը տարբեր է `Traffic_light::red`-ից։

Թվարկումներն օգտագործվում են ամբողջաթիվ արժեքների փոքր խմբեր ներկայացնելու համար։ Դրանք օգտագործվում են ծրագրի տեքստն ավելի ընթեռնելի և սխալների հնարավորությունից ավելի զերծ պահելու համար, քան դա դա կարելի էր անել առանց սիմվոլիկ (և հեշտ հիշվող՝ մնեմոնիկ) թվարկվող անունների օգտագործամբ։

`enum`-ից հետո գրված `class`-ը նշում է, որ թվարկումը խիստ տիպիզացված է և դրա թվարկելիներն իրենց սեփական տիրույթում են։ Լինելով առանձին տիպեր, `enum class`-ներն օգնում են խուսափել հաստատունների պատահական շփոթումից։ Մասնավորապես, մենք չենք կարող շփոթել `Traffic_light` և `Color` արժեքները.

```C++
Color x = red;                  // սխալ. ո՞ր red-ը
Color y = Traffic_light::red;   // սխալ. այս red-ը Color-ց չէ
Color z = Color::red;
```

Նմանապես, չենք կարող `Color`-ի արժեքները և ամբողջ թվերը օգտագործել իրար հետ․

````C++
int i = Color::red;        // սխալ, Color::red-ը int չէ
Color c = 2;               // ինիցիալիզացիայի սխալ, 2-ը Color-ց չէ
````

Մի որևէ արժեքն `enum`-ին ձևափոխելու փորձի ստուգումը լավ պաշտպանություն է սխալներից, բայց հաճախ մեզ պետք է լինում `enum`-ն արժեքավոր դրա բազային տիպի (լռելությամբ դա `int`-ն է) արժեքով. դա հնարավոր է բազային տիպից բացահայտ ձևափոխությամբ. ??

```C++
Color x = Color{5};  // OK, but verbose
Color y {6};         // also OK
```

Լռելությամբ `enum class`֊ի համար սահմանված են հավասարության, ինիցիալիզացիայի և համեմատության գործողությունները (օր․`==` և `<`; §1.5)։ Սակայն թվարկումն օգտագործողի սահմանած տիպ է, հետևաբար կարող ենք նրա համար սահմանել օպերատորներ․

```C++
Traffic_light& operator++(Traffic_light& t)
       // նախածանցային ինկրեմենտ՝ ++
{
        switch(t){
        case Traffic_light::green:      return t = Traffic_light::yellow;
        case Traffic_light::yellow;      return t = Traffic_light::red;
        case Traffic_light::red;           return t = Traffic_light::green;
        }
}

Traffic_light next = ++light;
```

Եթե չեք ցանկանում խստորեն նշել թվարկման անունները և ուզում եք, որ արժեքները լինեն `int`-եր (առանց բացահայտ ձևափոխման), ապա կարող եք հեռացնել  `class` անունը `enum class`֊ից՝ «պարզ» `enum` ստանալու համար: «Պարզ» `enum`-ով սահմանված անունները ներմուծվում են տեսանելիության միևնույն տիրույթ, որտեղ իրենց `enum`-ի անունն է և ոչ ակնհայտորեն ձևափոխվում են իրենց ամբողջ արժեքներին։ Օրինակ․ ???

```C++
enum Color {red, green, blue};
int col = green;
```

Այստեղ `col`֊ը ստանում է `1` արժեքը։ Լռելությամբ թվարկվող անունների ամբողջ արժեքներն սկսում են `0`֊ից և ավելանում են մեկով՝ յուրաքանչյուր թվարկվող անվան հետ։ «Հասարակ» `enum`-ները եղել են C++-ում (և C-ում) ամենավաղ օրերից, և թեև նրանց վարքը այնքան էլ լավը չէ, դրանք ընթացիկ կոդերում էլ գործածելի են։ ???


## 2.6 Խորհուրդներ

1. Եթե ներդրված տիպերը չափազանց ցածր մակարդակի են, ապա նախապատվությունը տվեք լավ սահմանված օգտագործողի տիպերին, §2.1։
2. Իրար հետ կապ ունեցող տվյալները միավորեք ստրուկտուրաների մեջ (`struct` կամ `class`), §2.2։
3. Դասի սահմանումով սահմանազատեք ինտերֆեյսն ու իրականացում, §2.3։
4. `struct`-ը նույն `class`-ն է՝ լռելությամբ `public` անդամներով, §2.3։
5. Սահմանեք կոնստրուկտորներ, որպեսզի պարզեցվի և երաշխավորվի `class`-երի ինիցիալիզացիան։
6. Խուսափե՛ք «մեր» `union`-ներից, տիպի դաշտի հետ միասին դրանք ընդգրկեք դասի մեջ, §2.4։
7. Օգտագործե՛ք թվարկումները անվանված հաստատունների բազմություն ներկյացնելու համար, §2.5։
8. Անակնկալներից խուսափելու համար «պարզ» `enum`-ներից և `class enum`-ներից նախապատվությունը տվեք վերջիններիս, §2.5։
9. Ապահով ու պարզ օգտագործման համար սահմանեք թվարկումների գործողություններ, §2.5։
