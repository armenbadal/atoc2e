# Տողեր և կանոնավոր արտահայտություններ

_Prefer the standard to the offbeat._

_— Strunk & White_

## Ներածություն

Տեքստի հետ աշխատանքը շատ ծրագրերի հիմնական մասն է։ C լեզվի ոճով նիշերի զանգվածների հետ ցուցիչների օգնությամբ աշխատելուց օգտագործողին զերծ պահելու համար C++ լեզվի ստանդարտ գրադարանն առաջարկում է `string` տիպը։ `string_view` տիպը հնարավորություն է տալիս աշխատել նիշերի հաջորդականությունների հետ՝ որտեղ էլ որ նրանք գրառված լինեն (այսինքն՝ `std::string` օբյեկտում կամ `char[]` զանգվածում)։ Ի լրումն, կոնոնավոր արտահայտություններին համապատասխանեցումը առաջարկվում է տեքստում ձևանմուշների (pattern) որոնման համար։ Կանոնավոր արտահայտությունները ներկայացված են այնպես, ինչպես դրանք առկա են շատ ծրագրավորման լեզուներում։ Թե՛ `string`, թե՛ `regex` օբյեկտներում կարող են օգտագործվել տարատեսակ նիշեր (օրինակ, Unicode)։


## Տողեր

Ստանդարտ գրադարանը `string` տիպն առաջարկում է ի լրումն տեքստային լիտերալների (§1.2.1)։ The standard library provides a string type to complement the string literals (§1.2.1)։ Տարբեր տիպերի նիշեր պահելու և դրանց հետ աշխատելու համար գրադարանը տրամադրում է `Regular` տիպը (§7.2, §12.7)։ `string` տիպը տրամադրում է զանազան օգտակար տողային գործողություններ, ինչպիսին է միակցումը (concatenation)։ Օրինակ.

```C++
string compose(const string& name, const string& domain)
{
    return name + '@' + domain;
}

auto addr = compose("dmr","bell−labs.com");
```

Այստեղ `addr`-ն արժեքավորվում է նիշերի `dmr@bell−labs.com` հաջորդականությամբ։ Տողերի «գումարումը» հենց միակցումն է։ `string`-ը կարող եք միակցել մի այլ `string`-ի, տողային լիտերալի, C-ոճով տողի կամ նիշի հետ։ Ստանդարտ `string`-ն ունի տողափոխող (move) կոնստրուկտոր, որը հնարավոր է դարձնում ֆունկցիայից նույնիսկ շատ երկար `string`-ների արդյունավետ վերադարձնելը (§5.2.2)։

Շատ կիրառություններում միակցման ամենատարածված տեսակը `string`-ի պոչից ինչ-որ բան ավելացնելն է։ Սա ուղղակիորեն առաջարկվում է `+=` գործողությամբ։ Օրինակ.

```C++
void m2(string& s1, string& s2)
{
    s1 = s1 + '\n';  // կցել նոր տողի նիշը
    s2 += '\n';      // կցել նոր տողի նիշը
}
```

Տողի վերջից կցելու այս երկու եղանակներն էլ ունեն համարժեք իմաստ, բայց ես նախընտրում եմ վերջինը, քանի որ այն ավելի ուղղակիորեն, ավելի հակիրճ և, միգուցե, ավելի արդյունավետ է արտահայտում գործողության իմաստը։

`string`-ը փոփոխելի (mutable) է։ Ի լրումն `=` և `+=` գործողությունների, առաջարկվում են նաև ինդեքսավորման (օգտագործելով `[]` փակագծերը) և ենթատողի առանձնացման գործողությունները։ Օրինակ.

```C++
string name = "Niels Stroustrup";

void m3()
{
    string s = name.substr(6,10);   // s = "Stroustrup"
    name.replace(0,5,"nicholas");   // name-ը դառնում է "nicholas Stroustrup"
    name[0] = toupper(name[0]);     // name-ը դառնում է "Nicholas Stroustrup"
}
```

`substr()` գործողությունը վերադարձնում է `string` օբյեկտ, որը արգումենտներով որոշվող ենթատողի պատճենն է։ Առաջին արգումենտը նպատակային ենթատողի ինդեքսն է (դիրքը) `string`-ում, իսկ երկրորդը՝ երկարությունը։ Քանի որ ինդեքսավորումը `0`-ից է, `s`-ը դառնում է `Stroustrup`։

`replace()` գործողությունը ենթատողը փոխարինում է տրված արժեքով։ Այս դեպքում `0` ինդեքսով սկսվող և `5` երկարությամբ ենթատողը `Niels` է. այն փոխարինվել է `nicholas`-ով։ Վերջապես, ես փոխարինում եմ առաջին տառն իր համարժեք մեծատառով։ Այսպիսով, `name`-ի վերջնական արժեքն է `Nicholas Stroustrup`։ Նշենք՝ ամենևին էլ անհրաժեշտ չէ, որ փոխարինող արժեքը ունենա փոխարինվող ենթատողի նույն երկարությունը։

Ի թիվս այլնի, `string`-ի օգտակար գործողություններից են վերագրումը (արտահայտված `=`-ով), ինդեքսավորումը (արտահայտված `[]`-ով կամ `at()`-ով, ինչպես `vector`-ում, §11.2.2), համեմատումը (արտահայտված `==`-ով և `!=`-ով), բառարանային կարգավորումը (արտահայտված `<`, `<=`, `>` և `>=` գործողություններով), իտերացիան (օգտագործելով իտերատորներն ինչպես `vector`-ում, §12.2), ներմուծումը (§10.3), և հոսքերի հետ աշխատանքը (§10.8)։

Իսկապես, `string`-ները կարող են համեմատվել միմյանց հետ, C-ոճի տողերի հետ և տեքստային լիտերալների հետ։ Օրինակ.

```C++
string incantation;

void respond(const string& answer)
{
    if (answer == incantation) {
        // perform magic
    }
    else if (answer == "yes") {
        // ...
    }
    // ...
}
```

Եթե ձեզ հարկավոր է C-ոճի տող (`char` տիպի նիշերի զրոյով վերջացող զանգված), ապա `string` դասն առաջարկում է իր պարունակած նիշերի միայն կարդալու համար նախատեսված մատչելիություն։ Օրինակ.

```C++
void print(const string& s)
{
    printf("For people who like printf: %s\n", s.c_str());     // s.c_str()-ը վերադարձնում է ցուցիչ s-ի նիշերին
    cout << "For people who like streams: " << s << '\n';
}
```

Ըստ սահմանման տեքստային լիտերալի տիպը `const char*` է։ `std::string` տիպի լիտերալ ստանալու համար օգտագործեք `s` վերջածանցը։ Օրինակ.

```C++
auto s = "Cat"s;   // std::string
auto p = "Dog";    // C-ոճով տող՝ const char*
```

`s` վերջածանցն օգտագործելու համար պետք է օգտվեք `std::literals::string_literals` անունների տիրույթից (§5.4.4)։


### `string`-ի իրականացումը

Տողերի դասն իրականացնելը տարածված ու օգտակար վարժություն է։ Բայց այնուամենայնիվ, ընդհանուր օգտագործման համար մեր խնամքով մշակված առաջին մոտեցումը հազվադեպ է համապատասխանում ստանդարտ `string`-ի հարմարությանն ու արտադրողականությանը։ Այժմ `string`-ը սովորաբար իրականացվում է _կարճ-տողերի օպտիմիզացիայի_ սկզբունքով։ Այսինքն, կարճ տեքստային արժեքները պահվում են `string` օբյեկտում, և միայն երկար տողերն են պահվում հիշողության ազատ տիրույթում։ Դիցուք.

```C++
string s1 {"Annemarie"};               // կարճ տող է
string s2 {"Annemarie Stroustrup"};    // երկար տող է
```

Հիշողության պատկերը կլինի մոտավորապես այսպես.

    nkar

Երբ `string`-ի արժեքը փոխվում է կարճից երկարի, կամ հակառակը, նրա ներքին ներկայացումը փոխվում է համապատասխան կերպ։ Քանի՞ նիշ կարող է ունենալ «կարճ» տողը։ Դա որոշվում է իրականացմամբ, բայց «մոտ 14 նիշը» վատ մոտարկում չէ։

`string`-ների իրական արտադրողականությունը կարող է էապես կախված լինել կատարման միջավայրից։ Մասնավորապես, բազմահոսք իրականացումներում հիշողության հատկացումը կարող է հարաբերականորեն «թանկ» լինել։ Ինչպես նաև, երբ օգտագործված են տարբեր երկարություններով շատ տողեր, արտադրողականության վրա կարող է ազդել նաև հիշողության կտրտվածությունը (fragmentation)։ Սրանք են այն հիմնական պատճառները, որոնք կարճ-տողերի օպտիմիզացիան դարձրել են ամենուրեք ընդունված։

Նիշերի տարբեր բազմությունների հետ աշխատանքն ապահովելու համար `string`-ն իրականում սահմանված է որպես `basic_string` կաղապարի կոնկրետացում՝ `char` տիպով։

```C++
template<typename Char>
class basic_string {
    // ... string of Char ...
};

using string = basic_string<char>
```

Օգտագործողը կարող է սահմանել կամայական տիպերի տողեր։ Օրինակ, ենթադրենք ունենք ճապոնական նիշերի `Jchar` տիպը, ապա կարող ենք գրել.

```C++
using Jstring = basic_string<Jchar>;
```

Հիմա կարող ենք տեքստային բոլոր գործողությունները կատարել `Jstring` տիպի՝ ճապոնական նիշերի տողերի հետ։


## String Views

Նիշերի հաջորդականությունն առավել հաճախ օգտագործվում է մի որևէ ֆունկցիայի փոխանցելիս։ ?? Դրան կարելի է հասնել `string`֊ի արժեքը, տողի հղումը, կամ C-ոճի տողի ցուցիչը ֆունկցիային փոխանցելով։ Շատ համակարգերում կան այլ տարբերակներ ևս, ինչպիսիք են, օրինակ, ստանդարտում չներառված տողային տիպերը։ ?? Բոլոր դեպքերում էլ առկա են լրացուցիչ դժվարություններ, երբ ուզում ենք ֆունկցիային փոխանցել ենթատողը։ Այս տիպի խնդիրները սպասարկելու համար ստանդարտ գրադարանը ներառում է `string_view`֊ն, որը պարզապես նիշերի հաջորդականությունը որոշող (ցուցիչ, երկարություն) զույգ է։

    նկար

`string_view`֊ն մատչելի է դարձնում նիշերի անընդհատ հաջորդականություն։ Նիշերը կարող են պահվել շատ տարբեր տեղերում, ներառյալ `string` օբյեկտը և C-տիպի տողը։ `string_view`֊ն նման է ցուցիչի կամ հղման, որին չեն պատկանում իր ցույց տված նիշերը։ ?? Այդ կերպ այն հիշեցնում է STL֊ի իտերատորների զույգ (§12.3)։

Պատկերացրեք երկու տողեր միակցող մի պարզ ֆունկցիա․

```C++
string cat(string_view sv1, string_view sv2)
{
    string res(sv1.length()+sv2.length());
    char* p = &res[0];
    for (char c : sv1) // one way to copy
        *p++ = c;
    copy(sv2.begin(),sv2.end(),p); // another way
    return res;
}
```

`cat()` ֆունկցիան կարող ենք կիրառել հետևյալ եղանակներով․

```C++
string king = "Harold";
auto s1 = cat(king,"William");             // string և const char*
auto s2 = cat(king,king);                  // string և string
auto s3 = cat("Edward","Stephen"sv);       // const char* և string_view
auto s4 = cat("Canute"sv,king);
auto s5 = cat({&king[0],2},"Henry"sv);     // HaHenry
auto s6 = cat({&king[0],2},{&king[2],4});  // Harold
```

Այս `cat()` ֆունկցիան երեք առավելություն ունի `compose()`-ի նկատմամբ, որը ստանում է `const string&` արգումենտներ (§9.2).

* Այն կարող է օգտագործվել տարբեր եղականկներով իրականացված նիշերի հաջորդականությունների հետ։
* C-ոճի տողային արգումենտների համար ժամանակավոր `string` արգումենտներ չեն ստեղծվում։
* Կարող ենք հեշտությամբ փոխանցել ենթատողերը։

Ուշադրություն դարձրեք նաև `sv` («string view») վերջածանցին։ Այն օգտագործելու համար պետք է ավելացնել.

```C++
using namespace std::literals::string_view_literals;   // §5.4.4
```

Ինչի՞ համար։ Պատճառն այն է, որ երբ `"Edward"`-ը փոխանցում ենք ֆունկցիային, `string_view`-ն պետք է կառուցել `const char*`-ից, որ պահանջում է հաշվել նիշերը։ `"Stephen"sv`-ի երկարությունը հաշվվում է կոմպիլյացիայի ժամանակ։

Երբ ֆունկցիայից վերադարձնում եք `string_view`, հիշեք, որ որ այն շատ նման է ցուցիչի՝ այն պետք է մի ինչ-որ բանի ցույց տա.

```C++
string_view bad()
{
    string s = "Once upon a time";
    return {&s[5],4};        // վատ է. վերադարձնում է լոկալ օբյեկտի ցուցիչ
}
```

Այստեղ վերադարձնում ենք այնպիսի մի `string`-ի նիշերի ցուցիչ, որը կոչնչացվի ավելի շուտ, քան կհասցնենք այն օգտագործել։

`string_view`-ի կարևոր սահմանափակումներից մեկն այն է, որ այն ապահովում է իր նիշերի միայն կարդալու համար մատչելիություն։ ?? Օրինակ, դուք չեք կարող `string_view`-ն օգտագործել նիշերը այնպիսի մի ֆունկցիայի փոկանցելու համար, որն իր արգումենտը դարձնում է փոքրատառերի։ Այդ նպատակի համար կարող եք օգտագործել `gsl::span`-ը կամ `gsl::string_span`-ը (§13.3).

`string-view`-ի սահմաններից դուր նիշին դիմելը անորոշ գործողություն է։ Եթե ցանկանում եք տիրույթի երաշխավորված ստուգում, օգտագործեք `at()`-ը, որը տիրույթից դուրս նիշին դիմելու դեպքում ծնում է `out_of_range` տիպի բացառություն, կամ էլ օգտագործեք `gsl::string_span` (§13.3), կամ էլ «պարզապես ուշադիր եղեք»։


## Կանոնավոր արտահայտություններ

Կանոնավոր արտահայտությունները տեքտերի մշակման հզոր գործիք են։ Դրանք հնարավորություն են տալիս պարզ ու արտահայտիչ եղանակով նկարագրել տեքստերի ձևանմուշներ (օրինակ, «TX 77845» տեքսի ԱՄՆ փոստային կոդը, կամ 2009−06−07 տեսքի ISO-ոճի ամսաթիվը), և արդյունավետ եղանակով տեքստում գտնել այդ ձևանմուշներին համապատասխանող հատվածները։ Ստանդարտ գրադարանը կանոնավոր արտահայտությունների հետ աշխատանքն ապահովում է `std::regex` դասով և դրան օժանդակող ֆունկցիաներով՝  սահմանված `<regex>` ֆայլում։ `regex` գրադարանի աշխատաոչի մասին պատկերացում կազմելու համար սահմանենք մի ձևանմուշ.

```C++
regex pat {R"(\w{2}\s*\d{5}(−\d{4})?)"};  // ԱՄՆ փոստային կոդի ձևանմուշը. XXddddd-dddd
```
