# Դասեր

_Այդ տիպերը «վերացական» չեն. դրանք այնքան իրական են, որքան `int`-ը և `float`-ը:_

_— Դաֆ Մակլորի (Doug Mcllroy)_


* Ներածություն
* Կոնկրետ տիպեր
      Թվաբանական տիպ; Կոնտեյներ; Կոնտեյներների սկզբնարժեքավորում
* Աբստրակտ տիպեր
* Վիրտուալ ֆունկցիաներ
* Դասերի հիերարխիա
      Բացահայտ վերասահմանում; Հիերարխիաներից ստացված օգուտները; Հիերարխիայի ղեկավարում; Ռեսուրսների հոսքից խուսափում
* Կրկնօրինակում և տեղաշարժում
      Կոնտեյներների կրկնօրինակում; Կոնտեյներների տեղաշարժում; Հիմնական գործողությունները; Ռեսուրսների կառավարում; Suppressing Operations
* Խորհուրդներ


## 4.1 Ներածություն

Այս և հաջորդ գլուխները նպատակ ունեն տալ գիտություն C++ լեզվի աբստրակցիայի և ռեսուրսների կառավարման մասին առանց շատ մանրամասնությունների․
* Այս գլուխը պարզ ձևով ներկայացնում է նոր տիպերի սահմանման և կիրառման(օգտագործման) ձևերը (*օգտագործողի սահմանած տիպեր*)։ Մասնավորապես այն ներկայացնում է *կոնկրետ դասերի*, *աբստրակտ դասերի*, և *դասերի հիերարխիաների* համար կիրառվող հիմնական հատկությունները, իրականացման տեխնիկան և լեզվական գործիքները։ 
* Հաջորդ գլուխը ներկայացնում է շաբլոնները որպես մեխանիզմ պարամետրիզացված տիպերի համար և ալգորիթմների համար with (other) types and algorithms․ Հաշվարկները օգտագործողի սահմանած տիպերի և ներդրված տիպերի վրա ներկայացված են որպես ֆունկցիաներ (ֆունկցիաների տեսքով), երբեմն դրանք *ընդհանրացված են* որպես *շաբլոն ֆունկցիաներ* և *ֆունկցիա օբյեկտներ*։ 

Այս ամենը լեզվի հարմարություններ են, որոնք տրամադրում են (ապահովում են) (support) *օբյկետ֊կողմնորոշված ծրագրավորում* և *ընդհանրացված ծրագրավորում* ծրագրավորման ուղղությունները (styles)։ 6-13 գլուխները զարգացնում և հասցնում են ավարտին՝ ներկայացնելով օրինակներ՝ ստանդարտ գրադարանի հարմարություններով և դրանց օգտագործումով։

C++ լեզվի կենտրոնական դետալը (բնութագրական առանձնահատկությունը)(feature) *դասն* է։ Դասը օգտագործողի սահմանած տիպ է, որը նախատեսված է ծրագրի կոդում ներկայացնելու որևէ հասկացություն։ Երբ ծրագրի համար մեր ստեղծած կառուցվածքն ունի (design) որևէ օգտակար հասկացություն, գաղափար, ամբողջություն և այլն, մենք փորձում ենք ծրագրի մեջ ներկայացնել այն որպես դաս, որպեսզի այդ հասկացությունը լինի հենց կոդի մեջ, այլ ոչ թե մեր գլխում, ձևակերպման փաստաթղթի մեջ կամ մի քանի մեկնաբանություններում։ Այն ծրագիրը, որը կառուցված է լավ ընտրված դասերի խմբից, շատ ավելի հեշտ է հասկանալ և get right, քան այն ծրագիրը, որն ամեն ինչ կառուցում է միայն ներդրված տիպերով։ Մասնավոր դեպքերում դասերը հաճախ հենց այն են, ինչ որ առաջարկում են գրադարանները։

Իրականում լեզվի բոլոր լրացուցիչ հնարավորությունները (հարմարությունները), չհաշված ֆունդամենտալ տիպերը, օպերատորները և արտահայտությունները, գոյություն ունեն, որպեսզի օգնեն սահմանել ավելի լավ դասեր կամ օգտագործեն դրանք ավելի հարմար ձևով։ «Ավելի լավ» ասելով ես նկատի ունեմ ավելի ճիշտ, ավելի հեշտ սպասարկվող, ավելի օգտավետ, ավելի էլեգանտ, ավելի հեշտ օգտագործելու համար, ավելի հեշտ կարդալու համար և ավելի հեշտ քննարկելու համար։ Ծրագրավորման տեխնիկաների մեծ մասը հենվում է առանձնահատուկ նշանակության դասերի ձևավորման և իրականացման վրա։ Ծրագրավորողների պահանջներն ու ճաշակները չափազանց տարբեր են։ Հետևաբար դասերի սատարումն էլ (support) լայն է։ Այստեղ մենք կդիտարկենք հիմնական support երեք կարևոր տեսակի դասերը․

* Կոնկրետ դասեր (§4.2)
* Աբստրակտ դասեր (§4.3)
* Դասեր դասերի հիերարխիաներում (§4.5)

Օգտակար դասերի ապշեցնող քանակը պարզվում է այս երեք տեսակներից որևէ մեկն է։ Դեռ ավելին, դասերը կարող են դիտարկվել որպես այս երեք տեսակների ավելի պարզ տարբերակներ կամ իրականացված են՝ օգտագործելով այդ դասերի համար օգտագործված տեխնիկաների կոմբինացիաները։


## 4.2 Կոնկրետ տիպեր

*Կոնկրետ դասերի* հիմնական գաղափարն այն է, որ նրանք իրենց պահում են "ներդրված տիպերի նման"։ Օրինակ, կոմպլեքս թվի տիպը և անվերջ֊չափողականությամբ(infinite-precision) ամբողջ տիպը շատ նման են ներդրված `int` տիպին, բացառությամբ այն բանի, իհարկե, որ նրանք ունեն իրենց սեփական սեմանտիկան և գործողությունների բազմությունը։ Նմանապես `vector`֊ը և `string`֊ը շատ նման են ներդրված զանգվածներին, բացառությամբ այն բանի, որ նրանց վարքն ավելի լավն է (§7.2, §8.3, §9.2)։

Կոնկրետ տիպի որոշիչ բնութագիրն այն է, որ նրա ներկայացումը նրա սահմանման մի մասն է։ Կարևոր շատ դեպքերում, օրինակ `vector`֊ի դեպքում, այդ ներկայացումը մեկ կամ մի քանի ցուցիչ է որոշ տվյալների վրա, որոնք տեղավորված են ինչ֊որ մեկ ուրիշ տեղում, սակայն այդ ցուցիչն առկա է կոնկրետ դասի յուրաքանչյուր օբյեկտում։ Սա թույլ է տալիս, որպեսզի իրականացումները օպտիմալ էֆեկտիվ լինեն ժամանակի և տեղի առումով։ Մասնավորապես դա մեզ թույլ է տալիս
* տեղավորել կոնկրետ տիպերի օբյեկտները ստեկում, ստատիկ հիշողությունում և ուրիշ օբյեկտներում (§1.6);
* դիմել օբյեկտներին ուղղակիորեն (և ոչ միայն ցուցիչների կամ հղումների միջոցով);
* սկզբնարժեքավորել օբյեկտները անմիջապես և ամբողջությամբ (օր․ օգտագործելով կոնստրուկտորները; §2.3); և
* պատճենել  (կրկնօրինակել) օբյեկտները (§4.6)

Ներկայացումը կարող է լինել փակ (ինչպիսին այն `Vector`֊ի համար է; §2.3) և հասանելի միայն անդամ֊ֆունկցիաների միջոցով, բայց այն կա։ Հետևաբար, եթե ներկայացումը փոփոխվում է ինչ֊որ էական կերպով, օգտագործողը պետք է այն նորից կոմպիլյացնի։ Սա է այն գինը , որը պետք է վճարել, կոնկրետ տիպեր ունենալու համար, որոնք պահում են իրենց ճշտորեն ներդրված տիպերի նման։ Սա ընդունելի է և հաճախ իդեալական այն տիպերի համար, որոնք հաճախ չեն փոփոխվում և որտեղ լոկալ փոփոխականներն ապահովում են այդքան անհրաժեշտ պարզություն և էֆեկտիվություն։ Ճկունությունն ավելացնելու համար կոնկրետ տիպը իր ներկայացման զգալի մասը կարող է պահել հիշողության ազատ տարածքում (free store) (դինամիկ հիշողություն, heap) և դիմել նրանց այն մասով, որը տեղավորված է հենց դասի օբյեկտի մեջ։ Հենց այս ձևով են իրականացվել `vector` և `string` դասերը; նրանք կարող են համարվել ռեսուրսների մշակիչներ զգուշորեն կազմակերպված ինտերֆեյսերով։

### 4.2.1 Թվաբանական տիպ

«Դասական օգտագործողի սահմանած թվաբանական տիպը» `complex`֊ն է․

````c++
   class complex {
         double re,im;                                                        // ներկայացում՝ երկու իրական թվեր
   public:
         complex (double r, double i) :re{r}, im{i} {}                         // կառուցել կոմպլեքս տիպ երկու սկալյարներից
         complex (double r) :re{r}, im{0} {}                                   // կառուցել կոմպլեքս տիպ մեկ սկալյարից
         complex () :re{0}, im{0} {}                                           // լռությամբ կոմպլեքս․ {0,0}

         double real() const {return re;}
         void real (double d) {re = d;}
         double imag() const {return im;}
         void imag (double d) {im = d;}

         complex& operator += (complex z) {re += z.re, im += z.im; return *this;}  // ավելացնել re֊ին և im֊ին 
                                                                                   // և վերադարձնել արդյունքը
         complex& operator -= (complex z) {re -= z.re, im -= z.im; return *this;}

         complex& operator *= (complex);                                           // defined out-of-class somewhere
         complex& operator /= (complex);                                           // defined out-of-class somewhere
};
````
Սա ստանդարտ-գրադարանի `complex`֊ի թեթևակի պարզեցրած տարբերակն է (§12.4)։ Դասի սահմանումն իր մեջ պարունակում է միայն այն գործողությունները, որոնք պահանջում են դիմել դասի ներկայացմանը։ Ներկայացումը պարզ է և պայմանական։ Պրակտիկ պատճառներով այն պետք է համատեղելի լինի այն ամենի հետ, ինչ Ֆորտրանն առաջարկել է 50 տարի առաջ, և մեզ անհրաժեշտ է օպերատորների պայմանական խումբ։ Ի հավելում տրամաբանական պահանջներին `complex`֊ը պետք է լինի էֆեկտիվ, հակառակ դեպքում այն կմնա չօգտագործված։ Սա նշանակում է, որ պարզ գործողությունները պետք է լինեն ներդրված։ Այսինքն, պարզ գործողությունները (ինչպիսիք են օրինակ կոնստրուկտորները, `+=`, և `imag()`) գեներացված մեքենայական կոդում պետք է իրականացված լինեն առանց ֆունկցիաների կանչերի։ Դասում սահմանված ֆունկցիաները համարվում են լռությամբ ներդրված։ Իրականում հնարավոր է ներդրում պահանջել բացահայտ կերպով՝ դնելով `inline` արմատական բառը  ֆունկցիայի հայտարարությունից առաջ։ An industrial-strength `complex` (ինչպիսին նաև ստանդարտ գրադարանինն է) իրականացված է զգուշորեն, որպեսզի կատարի համապատասխան ներդրումը։

Այն կոնստրուկտորը, որը կարող է կանչվել առանց որևէ արգումենտի կոչվում է *լռությամբ կոնստրուկտոր*։ Հետևաբար, `complex()`֊ը `complex`֊ի լռությամբ կոնստրուկտորն է։ Սահմանելով լռությամբ կոնստրուկտոր, դուք բացառում եք  այդ տիպի ոչ սկզբնարժեքավորված փոփոխականներ ունենալու հնարավորությունը։

Իրական և երևակայական մասերը վերադարձնող ֆունկցիաների վրա գտնվող `const` սպեցիֆիկատորները ցույց են տալիս, որ նրանք չեն ձևափոխում այն օբյեկտը, որի համար որ կանչվել են։

Շատ օգտակար գործողություններ չեն պահանջում ուղիղ դիմում `complex` տիպի ներկայացմանը, այդպիսով նրանք կարող են սահմանվել դասի սահմանումից առանձին․

````c++
   complex operator+(complex a, complex b) {return a += b;}
   complex operator-(complex a, complex b) {return a -= b;}
   complex operator-(complex a) {return {-a.real(), -a.imag()};}      // ունար հանում
   complex operator*(complex a, complex b) {return a *= b;}
   complex operator/(complex a, complex b) {return a /= b;}
````

Այստեղ ես օգտագործում եմ այն փաստը, որ արժեքով փոխանցված արգումենտը պատճենվում է, հետևաբար ես կարող եմ ձևափոխել արգումենտը առանց կպնելու կանչողի կրկնօրինակին և օգտագործել արդյունքը որպես վերադարձվող արժեք։

`==` և `!=` գործողությունների սահմանումներն ուղիղ են (straightforward)․

````c++
   bool operator==(complex a, complex b)      // հավասարություն
   {
      return a.real()==b.real() && a.imag()==b.imag();
   }

   bool operator!=(complex a, complex b)      // ոչ հավասարություն
   {
      return !(a==b);
   }

   complex sqrt(complex);      // սահմանումը գտնվում է մեկ ուրիշ տեղում

   // ...
````

`complex` դասը կարող է օգտագործվել հետևյալ կերպ․

````c++
   void f(complex z)
   {
      complex a{2.3};      // կառուցել {2.3, 0.0} կոմպլեքս թիվը 2.3֊ից
      complex b{1/a};
      complex c{a+z*complex{1, 2.3}};
      // ...
      if (c!=b)
            c = -(b/a) + 2*b;
   }
````

Կոմպիլյատորը ձևափոխում է `complex` թվեր պարունակող օպերատորները համապատասխան ֆունկցիաների կանչերի։ Օրինակ `c!=b`֊ն նշանակում է `operator!=(c,b)` և `1/a`նշանակում է `operator/(complex{1},a)`։

Օգտագործողի սահմանած  օպերատորները («գերբեռնված օպերատորները») պետք է օգտագործվեն զգուշորեն և պայմանականորեն։ Սինտաքսիսը ֆիքսված է լեզվի կողմից, այնպես որ դուք չեք կարող սահմանել ունար `/` գործողություն։ Նաև հնարավոր չէ փոխել օպերատորի նշանակությունը ներդրված տիպերի համար, այնպես որ դուք չեք կարող վերասահմանել `+`֊ը `int`֊երը հանելու համար։

## 4.2.2 Կոնտեյներ

*Կոնտեյները* օբյեկտ է, որը պահում է էլեմենտների հավաքածու, այսպիսով մենք կոչում ենք `Vector`֊ը կոնտեյներ, որովհետև այն այն տիպի օբյեկտներից է, որոնք կոնտեյներներ են։ Ինչպես, որ սահմանվել է §2.3֊ում, `Vector`֊ը `double`արժեքների անհիմն կոնտեյներ չէ՝ այն շատ պարզ է հասկանալու համար, հաստատում է օգտակար ինվարիանտ (§3.4.2), ապահովում է range-checked դիմում (§3.4.1) և ապահովում է `size()` ֆունկցիա, որը մեզ թույլ է տալիս անցնել նրա էլեմենտների վրայով։ Ինչևէ, այն ունի ճակատագրական սխալ՝ այն տեղադրում է էլեմենտներն օգտագործելով `new` օպերատորը բայց երբեք չի ազատում այդ տարածքները։ Սա լավ գաղափար չէ, քանի որ չնայած որ C++ լեզուն սահմանում է ինտերֆեյս garbage collector֊ի համար (§4.6.4), երաշխավորված չէ, որ one is available to make unused memory available for new objects. Որոշ միջավայրերում դուք չեք կարող օգտագործել հավաքիչը և երբեմն դու նախընտրում ես ջնջման ավելի ճշգրիտ հսկողություն տրամաբանական կամ էֆեկտիվության պատճառներից ելնելով։ Մեզ անհրաժեշտ է այնպիսի մեխանիզմ, որը կհավաստիացնի, որ այն հիշողությունը, որն առանձնացվել է կոսնտրուկտորի կողմից, ազատվել է; այդ մեխանիզմը *դեստրուկտորն է*․

````c++
   class Vector {
   private:
         double* elem;      // elem֊ը ցույց է տալիս sz հատ double֊ների զանգվածի վրա
         int sz;
   public:
         Vector(int s) : elem{new double[s]}, sz{s}      // կոնստրուկտոր՝ ստանալ ռեսուրսներ
         {
               for (int i = 0; i != s; ++i)      // ինիցիալիզացնել էլեմենտները
                     elem[i] = 0;
         }

         ~Vector() {delete[] elem;}      // դեստրուկտոր՝ բաց թողնել ռեսուրսները

         double& operator[](int i);
         int size() const;
   };
````

Դեստրուկտորի անունը հանդիսանում է`~` օպերատորի լրացումը, որից հետո գալիս է դասի անունը; այն հանդիսանում է կոնստրուկտորի լրացում։ `Vector`֊ի կոնստրուկտորն առանձնացնում է ինչ֊որ չափի հիշողություն հիշողության ազատ տարածքում՝ (որը կոչվում է նաև *heap* կամ *դինամիկ տարածք*) օգտագործելով `new` օպերատորը։ Դեստրուկտորը մաքրում է ազատելով այդ տարածքը՝ օգտագործելով `delete` օպերատորը։ Այս ամենը կատարվում է առանց `Vector`֊ի օգտագործողների միջամտության։ Օգտագործողները պարզապես ստեղծում և օգտագործում են `Vector`֊ներ այնքան, ինչքան որ փոփոխականները ներդրված տիպերի։ Օրինակ․

````c++
   void fct(int n)
   {
         Vector v(n);

         // ... v-ի կիրառումը

         {
               Vector v2(2*n);
               // ... v֊ի և v2֊ի կիրառումը
         } // v2-ը այստեղ ջնջվում է

          // ․․․ v֊ի կիրառումը ..

   } // v֊ն ջնջվում է այստեղ
````

`Vector`֊ը ենթարկվում է միևնույն կանոններին անվանելու, տեսանելիության տիրույթի, տարածքի, կյանքի տևողության և այլն համար (§1.6), ինչպես որ անում է ներդրված տիպը, այնպիսին ինչպիսին է `int`֊ը և `char`֊ը։ Այս `Vector`֊ը պարզեցված է by leaving out error handling; տե՛ս §3.4։ 

   Կոնստրուկտոր/դեստրուկտոր կոմբինացիան շատ էլեգանտ տեխնիկաների հիմքն է։ Մասնավորապես այն համարվում է C++ լեզվի հիմնական ռեսուրսների կառավարման տեխնիկաների մեծ մասի հիմքը (§11.2)։ Եկեք նայենք `Vector`֊ի գրաֆիկական լուսաբանումը․

նկար գլուխ 4.2.2

Կոնստրուկտորը հարկ եղած ձևով տեղադրում է էլեմենտները և ինիցիալիզացնում է `Vector`֊ը։ Դեստրուկտորը դատարկում է էլեմենտները։ Այս *handle-to-data model*֊ը շատ լավ կիրառվում է՝ ղեկավարելու համար այն տվյալները, որոնք կարող են փոփոխվել չափով, օբյեկտի կյանքի տևողության ընթացքում։ Ռեսուրսների ձեռքբերման տեխնիկան կոնստրուկտորում և դրանց բացթողնումը դեստրուկտորում, որը հայտնի է որպես Resource Acquisition Is Initialization or RAII, մեզ թույլ է տալիս վերացնել «մերկ `new`գործողությունները» that is, to avoid allocations in general code
and keep them buried inside the implementation of well-behaved abstractions. Similarly, ‘‘naked delete operations’’ should be avoided. Avoiding naked new and naked delete makes code far less error-prone and far easier to keep free of resource leaks (§11.2).

## 4.2.3 Կոնտեյներների ինիցիալիզացում

Կոնտեյները տարրերը պահելու համար է, ակնհայտորեն մեզ անհրաժեշտ են հարմար ճանապարհներ տարրերը կոնտեյների մեջ ստանալու համար։ Մենք կարող ենք handle դա՝ ստեղծելով `Vector`՝ համապատասխան թվով տարրերով և հետո վերագրենք նրանց արժեքներ, բայց որպես կանոն մյուս տարբերակները ավելի առաջնակարգ են։ Այստեղ ես ուղղակի նշում եմ երկու ամենակիրառվողները․
* _Ինիցիալիզացիոն լիստով կոնստրուկտոր՝_ ինիցիալիզացնել տարրերի ցանկով։
* `push_back()․` Ավելացնել նոր տարր հաջորդականության (ետևից) վերջում։ 

Վերջիններս կարող են հայտարարվել հետևյալ կերպ․

````c++
   class Vector {
   public:
            Vector (std::initializer_list<double>);      // ինիցիալիզացնել իրական թվերի ցանկով
            // ...
            void push_back(double);            // ավելացնել էլեմենտ վերջից՝ մեծացնելով չափը մեկով
            // ...
   };
````

`push_back`֊ն օգտակար է պատահական քանակի տարրերի ներմուծման դեպքում։ Օրինակ

````c++
   Vector read(istream& is)
   {
         Vector v;
         for (double d; is >> d;)      // կարդալ սահող ստորակետով արժեքները d ֊ի մեջ
               v.push_back(d);            // ավելացնել v֊ին
         return v;
   }
````

Ներմուծման ցիկլն ավարտվում է ֆայլի վերջով (end-of-file) կամ ֆորմատավորման սխալով։ Մինչև դա, յուրաքանչյուր կարդացվող թիվ ավելացվում է `Vector`֊ին և այսպես մինչև վերջ, `v`֊ի չափը կարդացած տարրերի քանակն է։ Ես օգտագործել եմ `for`֊արտահայտությունը նախընտրելով ավելի ընդունված պայմանական `while`֊արտահայտությունից, որպեսզի `d`֊ի տեսանելիության տիրույթը սահմանափակ ցիկլի ներսում։ The way to provide Vector with a move constructor, so that returning a potentially huge amount of data from read() is cheap, is explained in §4.6.2.

`std::initializer_list`-ը, որն օգտագործվել է սահմանելու համար ինիցիալիզացիոն լիստով կոնստրուկտոր, ստանդարտ գրադարանի տիպ է, որը հայտնի է կոմպիլյատորին․ երբ մենք օգտագործում ենք `{}`֊ցուցակ, այնպիսին, ինչպիսինն է `{1,2,3,4}`֊ը, կոմպիլյատորը կստեղծի օբյեկտ `initializer_list` տիպով, որպեսզի տա ծրագրին։ Այսպիսով, մենք կարող ենք գրել․

````c++
   Vector v1 = {1,2,3,4,5};                   // v1֊ն ունի 5 տարր
   Vector v2 = {1.23, 3.45, 6.7, 8};      // v2֊ն ունի 4 տարր
````

`Vector`֊ի ինիցիալիզացիոն լիստով կոնստրուկտորը կարող էր սահմանվել հետևյալ կերպ․

````c++
   Vector::Vector(std::initializer_list<double> lst)      // ինիցիալիզացնել ցանկով
            :elem{new double[lst.size()]}, sz{static_cast<int>(lst.size())}
   {
            copy(lst.begin(), lst.end(), elem);            // պատճենել lst֊ից elem֊ի մեջ (§10.6)
   }
````

Ես օգտագործում եմ տգեղ `static_cast`֊ը՝ (§14.2.3) ձևափոխելու համար ինիցիալիզացիոն լիստի չափը `int` տիպի: Սա շատ մանրացրած է, քանի որ հնարավորությունը, որ ձեռքով գրված տարրերի քանակը մեծ կլինի ամենամեծ ամբողջից (32,767 16֊բիթ ամբողջների համար և 2,147,483,647 32-բիթ ամբողջների համար) շատ քիչ հավանական է: Ինչևէ it is worth remembering that the type system has no common sense. Այն գիտի փոփոխականների հնարավոր արժեքների մասին ավելի, քան փաստացի արժեքների մասին, so it might complain where there is no actual violation։ Ինչևէ, վաղ թե ուշ, այդպիսի զգուշացումները կփրկեն ծրագրավորողին վատ սխալներից։

`static_cast` հրամանը չի ստուգում այն արժեքը, որը որ ձևափոխում է; ծրագրավորողը հույս ունի, որ այն ճիշտ է օգտագործում։ Միշտ չէ, որ սա լավ ենթադրություն է, այնպես որ, եթե կասկածում եք, ստուգեք արժեքը։ Տիպի բացահայտ ձևափոխումներից (often called casts to remind you that they are used to prop up something broken) ավելի լավ է հրաժարվել։ Տիպերի համակարգի խելամիտ օգտագործումը և լավ ձևավորված գրադարանները մեզ թույլ են տալիս բացառել չստուգված վարքը բարձր մակարդակի ծրագրերում։

# 4.3 Աբստրակտ տիպեր

`complex`֊ի և `Vector`֊ի նման տիպերը կոչվում են *կոնկրետ տիպեր*, քանի որ նրանց ներկայացումը նրանց սահմանման մի մասն է։ Սրանով նրանք հիշեցնում են ներդրված տիպերը։ Դրան հակառակ, *աբստրակտ տիպը* տիպ է, որն ամբողջությամբ մեկուսացնում է օգտագործողին իրականացման մանրամասնություններից։ Դրան հասնելու համար մենք անջատում ենք ինտերֆեյսը ներկայացումից և տալիս ենք իսկական լոկալ փոփոխականներ։ Քանի որ մենք ոչ մի բան չգիտենք աբստրակտ տիպի ներկայացման մասին (և ոչ նույնիսկ նրա չափը), մենք պետք է տեղադրենք օբյեկտները հիշողության ազատ տարածքում (free store) (§4.2.2) և պետք է դիմենք նրանց հղումների կամ ցուցիչների միջոցով (§1.8, §11.2.1)։

Սկզբում մենք սահմանում ենք `Container` դասի ինտերֆեյսը, որը կձևավորի մեր `Vector` դասի մի քանի աբստրակտ տարբերակներ․

````c++
   class Container {
   public:
            virtual double& operator[](int) = 0;      // մաքուր վիրտուալ ֆունկցիա
            virtual int size() const = 0;                    // const անդամով ֆունկցիա (§4.2.1)
            virtual ~Container() {}                        // դեստրուկտոր (§4.2.2)
   };
```` 

Այս դասը մաքուր ինտերֆեյս է ավելի ուշ սահմանված կոնտեյներներ նշելու համար։ `virtual` բառը նշանակում է, որ «կարող է վերասահմանվել դասի մեջ հետագայում՝ ժառանգելով այս մեկից»։ Զարմանալի չէ, որ `virtual` հայտարարված ֆունկցիան կոչվում է *վիրտուալ ֆունկցիա*։ `Container`֊ից բխած դասը ապահովում է իրականացում `Container`֊ի ինտերֆեյսի համար։ The curious `= 0` սինտաքսիսն ասում է, որ ֆունկցիան *մաքուր վիրտուալ ֆունկցիա է*; սա նշանակում է, որ `Container`֊ից բխած ինչ֊որ դաս *պետք է* սահմանի այդ ֆունկցիան։ Այդ պատճառով, հնարավոր չէ ուղղակի սահմանել  `Container` օբյեկտ; `Container`֊ը կարող է ուղղակի ծառայել որպես ինտերֆեյս այն դասին, որն իրականացնում է իր `operator[]()` և `size()` ֆունկցիաները։ Այն դասը, որն ունի մաքուր վիրտուալ ֆունկցիա, կոչվում է *աբստրակտ դաս*։ 

   Այս `Container`֊ը կարող է օգտագործվել հետևյալ կերպ․

````c++
   void use (Container& c)
   {
         const int sz = c.size();

         for (int i = 0; i != sz; ++i)
               cout << c[i] << '\n';
   }
````

Ուշադրություն դարձրեք, թե ինչպես է `use()`֊ը օգտագործում `Container`֊ի ինտերֆեյսը, ամբողջությամբ անտեսելով իրականացման դետալները։ Այն օգտագործում է `size()`֊ը և`[]`֊ը առանց որևէ գաղափարի, թե նրանց իրականացումը ինչ տիպ է ապահովում։ Այն դասը, որն ապահովում է ինտերֆեյս այլ դասերի բազմության համար, հաճախ կոչվում է *պոլիմորֆիկ տիպ*։ 

   Ինչպես, որ հատուկ է աբստրակտ դասերին, `Container`֊ը չունի կոնստրուկտոր։ Վերջիվերջո, այն չունի որևէ տվյալ արժեքավորելու համար։ Մյուս կողմից `Container`֊ը ունի դեստրուկտոր և այդ դեստրուկտորը `virtual` է։ Կրկին, սա բնորոշ է աբստրակտ դասերին, քանի որ նրանք հակված են փոփոխվելու հղումների և ցուցիչների միջոցով, և որևէ մեկը, ով ջնջում է այն ցուցիչի միջոցով, գաղափար չունի, թե ինչ ռեսուրսներ են ստացվում ? նրա իրականացումով; տես նաև §4.5.

   Այն կոնտեյները, որն իրականացնում է այն ֆունկցիաները, որոնք պահանջվում են `Container` աբստրակտ դասի սահմանված ինտերֆեյսի կողմից, կարող է օգտագործել `Vector` կոնկրետ դասը․

````c++
   class Vector_container : public Container {    // Vector֊կոնտեյները իրականացնում է Container֊ը
         Vector v;
   public: 
            Vector_container (int s) : v(s) {}   // s տարրերի վեկտոր
            ~Vector_container() {}

            double& operator[](int i) {return v[i];}
            int size() const {return v.size();}
   };
````

`public:` բառը կարող է կարդացվել որպես «ժառանգված է» կամ «ենթատեսակ»։ Ասում են, որ `Vector_container` դասը *ժառանգված է* `Container` դասից և `Container` դասը `Vector_container` դասի *բազային* դասն է։ Այլընտրանքային տերմինոլոգիան անվանում է `Vector_container`֊ը և `Container`֊ը *ենթադաս* և *ծնող դաս* համապատասխանաբար։ Ասում են, որ ժառանգված դասը ժառանգում է իր բազային դասի անդամները, այսպիսով բազային և ժառանգված դասերի օգտագործումը սովորաբար կոչվում է *ժառանգում*։ 

`operator[]()` և `size()` անդամներն, ասում են *վերասահմանում են* *(override)* համապատասխան անդամները `Container` բազային դասում։ Դեստրուկտորը (`~Vector_container()`) վերասահմանում է բազային դասի դեստրուկտորը (`Container()`)։ Ուշադրություն դարձրեք, որ դեստրուկտոր անդամը (`~Vector()`) ոչ ակնհայտորեն կանչվում է իր դասի դեստրուկտորի կողմից (`~Vector_container()`)։ 

`use(Container&)`֊ի նման ֆունկցիայի համար, որպեսզի կարողանա օգտագործել `Container`֊ը՝ ամբողջությամբ անտեսելով իրականացման դետալները, որոշ այլ ֆունկցիաներ պետք է ստեղծեն մի օբյեկտ, որի վրա այն կարող է աշխատել։ Օրինակ․

````c++
   void g()
   {
         Vector_container vc {10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
         use (vc);
   }
````

Քանի դեռ `use()`֊ը չգիտի `Vector_container`֊ի ինտերֆեյսի մասին, բայց գիտի միայն `Container`֊ի ինտերֆեյսը, այն կաշխատի `Container`-ի մեկ ուրիշ իրականացման համար։ Օրինակ․

````c++
   class List_container : public Container {      // List_container֊ն իրականացնում է Container֊ը
         std::list<double> ld;      //  (ստանդարտ֊գրադարան) իրական թվերի ցուցակ (§9.3)
   public: 
            List_container() {}      // դատարկ ցուցակ
            List_container (initializer_list <double> il) : ld{il} {}
            ~List_container() {}

            double & operator[](int i);
            int size() const {return ld.size();}

   };

   double & List_container::operator[] (int i)
   {
         for (auto & x : ld) {
               if (i == 0) return x;
               --i;
         }
         throw out_of_range ("List container");
   }
````

Այստեղ ներկայացումը ստանդարտ գրադանի `list<double>`_ն է։ Սովորաբար ես չեմ իրականացնի կոնտեյները subscript գործողությամբ, օգտագործելով `list`֊ը, որովհետև `list`֊ի ներկայացումը subscripting is atrocious compared to vector subscripting։ Ինչևէ, այստեղ ես ցանկացա ցույց տալ մի իրականացում, որը հիմնովին տարբերվում է սովորականից։ 

   Ֆունկցիան կարող է ստեղծել `List_container` և ունենալ `use()` այն օգտագործելու համար․

````c++
   void h()
   {
         List_container lc = {1,2,3,4,5,6,7,8,9};
         use (lc);
   }
````

Այստեղ կարևոր կետն այն է, որ `use(Container &)`֊ը գաղափար չունի, թե ով է իր արգումենտը՝ `Vector_container`֊ը, `List_container`֊ը կամ մեկ ուրիշ կոնտեյներ; այն կարիք չունի դա իմանալու։ Այն կարող է օգտագործել ցանկացած տեսակի `Container`: Սա գիտի միայն `Container`֊ի սահմանած ինտերֆեյսը։ Հետևաբար կարիք չկա վերակոմպիլյացիայի ենթարկել`use(Container &)`֊ը, եթե փոխվում է `List_container`_ի իրականացումը կամ `Container`֊ից ստացված բոլորովին նոր դաս է օգտագործվում։

Այս ճկունության շրջված կողմն այն է, որ օբյեկտների հետ պետք է աշխատել ցուցիչների կամ հղումների միջոցով (§4.6, §11.2.1)։


## 4.4 Վիրտուալ ֆունկցիաներ

Եկեք դիտարկենք կրկին `Container` դասի կիրառումը․

````c++
   void use (Container & c)
   {
         const int sz = c.size();

         for (int i = 0; i != sz; ++i)
                  cout << c[i] << '\n';
   }
````

Ինչպե՞ս է `c[i]`֊ի կանչը `use()`֊ում լուծվում ճիշտ `operator[]()`֊ի կողմը։ Երբ `h()`֊ն կանչում է `use()`֊ին, պետք է կանչվի `List_container`֊ի `operator[]()` ֆունկցիա֊անդամը։ Երբ `g()`֊ն կանչում է `use()`֊ին, պետք է կանչվի `Vector_container`֊ի `operator[]()` ֆունկցիա֊անդամը։ Այս լուծմանը հասնելու համար `Container`դասի օբյեկտը պետք է պարունակի ինֆորմացիա, որը թույլ կտա նրան  կատարման ժամանակ ընտրել կանչի համար ճիշտ ֆունկցիան։ The usual implementation technique is for the compiler to convert the name of a virtual function into an index into a table of pointers to functions. Այդ աղյուսակը սովորաբար կոչվում է *վիրտուալ ֆունկցիաների աղյուսակ* կամ պարզապես `vtbl`։ Վիրտուալ ֆունկցիաներով յուրաքանչյուր դաս ունի իր սեփական `vtbl`, որն իդենտիֆիկացնում է նրա վիրտուալ ֆունկցիաները։ Սա գրաֆիկորեն կարելի է ներկայացնել հետևյալ կերպ․

նկար 4.4

`vtbl`֊ի ֆունկցիաները թույլ են տալիս օբյեկտին ունենալ ճիշտ կիրառություն, նույնիսկ եթե օբյեկտի չափը և նրա տվյալների դասավորությունը հայտնի չեն կանչողին։ Կանչողի (caller) իրականացման մեջ պետք է հայտնի լինի միայն `vtbl`֊ի ցուցիչի տեղը `Container`֊ում և յուրաքանչյուր վիրտուալ ֆունկցիայի համար օգտագործվող ինդեքսը։ Այս վիրտուալ կանչի մեխանիզմը կարող է դառնալ այնքան էֆեկտիվ, որքան «նորմալ ֆունկցիայի կանչի» մեխանիզմն է (within 25%)։ Its space overhead is one pointer in each object of a class with virtual functions plus one `vtbl` for each such class.


## 4.5 Դասերի հիերարխիան

`Container` դասի օրինակը դասերի հիերարխիայի շատ պարզ օրինակ է։ *դասերի հիերարխիան* դասերի խումբ է ordered in a lattice created by derivation (e.g., : public )։ Մենք օգտագործում ենք դասերի հիերարխիան, որպեսզի ներկայացնենք աստիճանական կապեր ունեցող հասկացություններ, այսպես օրինակ․ «Հրշեջ մեքենան բեռնատար մեքենայի մի տեսակ է, որն էլ համարվում է փոխադրամիջոցի մի տեսակ» և «Ժպտացող դեմքը շրջանի մի տեսակ է, որն էլ համարվում է պատկերի տեսակներից մեկը»։ Հարյուրավոր դասերով կազմված հսկա հիերարխիաները, որոնք և՛ խորն են և՛ լայն են, շատ կիրառելի են։ Որպես semi-realistic դասական օրինակ, եկեք դիտարկենք պատկերները էկրանի վրա․

նկար 4.5

Սլաքները ցույց են տալիս ժառանգական կապերը։ Օրինակ, `Circle` դասը ստացվել է `Shape` դասից։ Այս պարզ դիագրամը կոդում ներկայացնելու համար, առաջին հերթին պետք է նկարագրենք մի դաս, որը սահմանում է բոլոր պատկերների ընդհանուր հատկությունները․

````c++
   class Shape {
   public:
            virtual Point center() const = 0;      // մաքուր վիրտուալ ֆունկցիա
            virtual void move (Point to) = 0;

            virtual void draw() const = 0;         // draw on current "Canvas"
            virtual void rotate (int angle) = 0; 

            virtual ~Shape() {}                        // դեստրուկտոր
            // ...
   };
````

Բնականաբար, այդ ինտերֆեյսն աբստրակտ դաս է․ as far as representation is concerned, ամեն մի `Shape`֊ի համար *ոչ մի բան* ընդհանուր չէ (բացի ցուցիչի տեղը `vtbl`֊ի վրա)։ Տալով այս սահմանումը, մենք կարող ենք գրել ընդհանուր ֆունկցիաներ, որոնք աշխատում են պատկերների վրա ցույց տվող ցուցիչների վեկտորների հետ․

````c++
   void rotate_all (vector <Shape*>& v, int angle)   // պտտել v֊ի տարրերը angle աստիճանով
   {
         for (auto p : v)
                p -> rotate(angle);
   }
````

Առանձին պատկեր սահմանելու համար, մենք պետք է հաղորդենք, որ այն `Shape` է և նշենք նրա մասնավոր հատկությունները (ներմուծելով նրա վիրտուալ ֆունկցիաները)․

````c++
   class Circle : public Shape {
   public:
            Circle (Point p, int rr);         // կոնստրուկտոր

            Point center() const {return x;}
            void move (Point to) {x = to;}
            void draw() const;
            void rotate(int) {}            // գեղեցիկ պարզ ալգորիթմ
   private:
            Point x;            // կենտրոնը
            int r;                // ռադիուս
   };
````

So far, the `Shape`and `Circle` example provides nothing new compared to the `Container` and `Vector_container` example, but we can build further:

````c++
   class Smiley : public Circle {   // օգտագործել շրջանը որպես բազային դաս դեմքի համար
   public:
            Smiley (Point p, int r) : Circle {p,r}, mouth {nullptr} {}

            ~Smiley()
            {
                   delete mouth;
                   for (auto p : eyes)
                             delete p;
            }

            void move (Point to);

             void draw() const;
             void rotate (int);

             void add_eye(Shape* s) {eyes.push_back(s);}
             void set_mouth (Shape* s);
             virtual void win k(int i);      // wink eye number i

             // ...

   private:
            vector <Shape*> eyes;      // usually two eyes
            Shape* mouth;
   };
````

`push_back` անդամ֊ֆունկցիան իր արգումենտն ավելացնում է `vector`֊ին՝ (այստեղ `eyes`֊ն է) ավելացնելով այդ վեկտորի չափը մեկով։

Այժմ մենք կարող ենք սահմանել `Smiley::draw()` ֆունկցիան՝ օգտագործելով `Smiley`֊ի բազային դասի և `draw()`անդամ֊ֆունկցաների կանչերը․

````c++
   void Smiley::draw()
   {
         Circle::draw();
         for (auto p : eyes)
                  p -> draw();
         mouth -> draw();
   }
````

Ուշադրություն դարձրեք, թե ինչպես է `Smiley` դասը պահում իր աչքերը ստանդարտ գրադարանի `vector`֊ում և թե ինչպես է ջնջում դրանք իր դեստրուկտորում։ `Shape`֊ի դեստրուկտորը `virtual`է և `Smiley`֊ի դեստրուկտորը վերասահմանում է այն։ Վիրտուալ դեստրուկտորը էական է աբստրակտ դասի համար, որովհետև ստացված դասի օբյեկտը սովորաբար ղեկավարվում է այն ինտերֆեյսի միջոցով, որն ապահովում է նրա աբստրակտ բազային դասը։ Մասնավորապես այն կարող է ջնջվել բազային դասի վրա ցույց տվող ցուցիչի միջոցով։ Այնուհետև վիրտուալ ֆունկցիան կանչում է մեխանիզմ, որը հավաստիացնում է, որ համապատասխան դեստրուկտորն է կանչվել։ Այդ դեստրուկտորը հետո ոչ բացահայտ կերպով կանչում է իր բազային և անդամ դասերի դեստրուկտորները։

Այս պարզեցված օրինակում ծրագրավորողի խնդիրն է տեղադրել աչքերն ու բերանը համապատասխանաբար շրջանի ներսում՝ ներկայացնելով դեմք։

Մենք կարող ենք ավելացնել տվյալ անդամներ, գործողություններ, կամ ել երկուսն էլ, քանի որ մենք սահմանում ենք նոր դաս ձևափոխության օգնությամբ։ Սա տալիս է մեծ ճկունություն համապատասխան հնարավորություններով շփոթության և վատ դիզայնի համար։


## 4.5.1 Բացահայտ վերասահմանում

Ժառանգ դասի ֆունկցիան վերասահմանում է բազային դասում գտնվող վիրտուալ ֆունկցիան, եթե այդ ֆունկցիան ունի ճիշտ նույն անունն ու տիպը։ Մեծ հիերարխիաներում միշտ չէ, որ ակնհայտ է, թե վերասահմանումը նախատեսված է։ Ֆունկցիան թեթևակի տարբերվող անունով կամ թեթևակի տարբերվող տիպով կարող է նախատեսված լինել վերասահմանվելու համար կամ կարող է նախատեսված լինել համարվելու առանձին ֆունկցիա։ Այսպիսի դեպքերում խառնաշփոթից խուսափելու համար ծրագրավորողը կարող է բացահայտորեն հաղորդել, որ ֆունկցիան նախատեսվում է վերասահմանել։ Օրինակ I could (equivalently) have defined Smiley like this:

````c++
   class Smiley : public Circle {   // օգտագործել շրջանը, որպես բազային դեմքի համար
   public:
            Smiley (Point p, int r) : Circle {p,r}, mouth{nullptr} {}

            ~Smiley()
            {
                  delete mouth;
                  for (auto p : eyes)
                            delete p;
            }

            void move (Point to) override;

            void draw() const override;
            void rotate(int) override;

            void add_eye(Shape* s) {eyes.push_back(s);}
            void set_mouth(Shape* s);
            virtual void win (int i);         // wink աչքի i թիվը

            // ...

   private:
            vector <Shape*> eyes;      // սովորաբար երկու աչք
            Shape* mouth;
   };
````

Now, had I mistyped `move` as `mve`, I would have gotten an error because no base of `Smiley` has a virtual function called `mve`. Similarly, had I added `override` to the declaration of `wink()`, I would have gotten an error message.


## 4.5.2 Հիերարխիաների առավելությունները

Դասերի հիերարխիան տալիս է երկու տեսակի առավելություն․
* _Ինտերֆեյսի ժառանգում_։ Ժառանգված դասի օբյեկտը կարող է օգտագործվել որտեղ, որ պահանջվում է բազային դասի օբյեկտը։ `Container` և `Shape` դասերը օրինակներ են։ Այդպիսի դասերը հաճախ աբստրակտ դասեր են։
* _Իրականացման ժառանգում_։ Բազային դասն ապահովում է ֆունկցիաներ կամ տվյալներ, որոնք պարզեցնում են ժառանգված դասերի իրականացումը։ `Smiley`֊ի՝ `Circle`֊ի կոնստրուկտորի և `Circle::draw()`֊ի կիրառումները օրինակներ են։ Այդպիսի բազային դասերը հաճախ ունենում են տվյալ֊անդամներ և կոնստրուկտորներ։

Կոնկրետ դասերը, հատկապես փոքր ներկայացմամբ, շատ նման են ներդրված տիպերին․ մենք սահմանում ենք դրանք որպես լոկալ փոփոխականներ, դիմում ենք դրանց օգտագործելով իրենց անունները, պատճենում ենք դրանք և այլն։ Դասերի հիերարխիաներում դասերը տարբեր են․ մենք ձգտում ենք տեղադրել դրանք ազատ տարածքում՝ օգտագործելով `new`֊ն, և մենք դիմում ենք նրանց ցուցիչների կամ հղումների միջոցով։ Օրինակ, եկեք դիտարկենք այն ֆունկցիան, որը կարդում է պատկերները նկարագրող տվյալները ներմուծման հոսքից և կառուցում է համապատասխան `Shape`֊ի օբյեկտները․

````c++
   enum class Kind {circle, triangle, smiley};

   Shape* read_shape(istream& is)      // կարդա պատկերի նկարագրությունը is ներմուծման հոսքից
   {
            // ... կարդալ պատկերի վերնագիրը is հոսքից

            switch(k) {
            case Kind::circle: 
                  // կարդալ շրջանի տվյալները {Point, int} p֊ի և r֊ի մեջ
                  return new Circle{p,r};
            case Kind::triangle:
                  // կարդալ եռանկյան տվյալները {Point, Point, Point} p1֊ի p2֊ի և p3֊ի մեջ
                  return new Triangle{p1,p2,p3};
            case Kind::smiley:
                  // կարդալ ժպիտի տվյալները {Point, int, Shape, Shape, Shape} p֊ի, r֊ի, e1֊ի, e2֊ի և m֊ի մեջ
                  Smiley* ps = new Smiley{p,r};
                  ps -> add_eye(e1);
                  ps -> add_eye(e2);
                  ps -> set_mouth(m);
                  return ps;
            }
   }
````
Ծրագիրը կարող է օգտագործել այդ պատկերը կարդացողին հետևյալ կերպ․

````c++
   void user()
   {
         std::vector<Shape*> v;
         while (cin)
                  v.push_back(read_shape(cin));
         draw_all(v);                  // կանչել draw()֊ն յուրաքանյուր տարրի համար
         rotate_all(v,45);           // կանչել rotate(45) յուրաքանչյուր տարրի համար
         for (auto p : v)             // հիշել ջնջել տարրերը
                  delete p;
   }
````

Ակնհայտ է, որ օրինակը պարզեցված է, հատկապես սխալների մշակման գործում, բայց այն կենդանի ձևով ցույց է տալիս, որ `user()`֊ը բոլորովին պատկերացում չունի, թե որ տեսակի պատկերի հետ է գործողություններ կատարում։ `user()` կոդը կարող է կոմպիլյացիայի ենթարկվել մեկ անգամ և հետագայում օգտագործվել նոր `Shape`֊երի համար՝ ավելացվելով ծրագրին։ Ուշադրություն դարձրեք, որ չկա ոչ մի այլ ցուցիչ պատկերների վրա `user()`֊ից դուրս, այնպես որ `user()`֊ը պատասխանատու է դրանք հեռացնելու համար։ Սա արվում է `delete` օպերատորի միջոցով և հենվում են `Shape`֊ի վիրտուալ դեստրուկտորի վրա։ Քանի որ այդ դեստրուկտորը վիրտուալ է, ապա `delete` օպերատորը կանչում է դեստրուկտորը ժառանգված դասերի մեծ մասի համար։ Սա որոշիչ է, որովհետև ժառանգված դասը կարող է ունենալ acquired all kinds of resources (such as file handles, locks, and output streams) that need to be released. In this case, a Smiley deletes its ey es and mouth objects.


## 4.5.3  Հիերարխիայի ղեկավարում (navigation)

`read_shape()` ֆունկցիան վերադարձնում է `Shape*`, այնպես որ մենք կարող ենք դիտարկել բոլոր նման `Shape`֊երը։ Այնուամենայնիվ, ի՞նչ կարող ենք մենք անել, եթե ցանկանում ենք օգտագործել մի անդամ֊ֆունկցիա, որն ապահովվում է մասնավոր ժառանգված դասից, ինչպիսին է `Smiley`֊ի `wink()`֊ը։ Մենք կարող ենք հարցնել․ «Արդյո՞ք այս `Shape`֊ը `Smiley`֊ի տեսակ է»՝ օգտագործելով `dynamic_cast` օպերատորը։

````c++
   Shape* ps{read_shape(cin)};

   if (Smiley* p = dynamic_cast<Smiley*>(ps)) {
            // ... is the Smiley pointer to by p ...
   }
   else {
            // ... not a Smiley, try something else...
   }
````

Եթե օբյեկտը, որը ցույց է տրվում `dynamic_cast`֊ի արգումենտի միջոցով (այստեղ `ps`) սպասվող տիպի չէ (այստեղ `Smiley`) կամ դասը ժառանգված սպասվող տիպից, `dynamic_cast`֊ը վերադարձնում է `nullptr`։ 

Մենք օգտագործում ենք `dynamic_cast` ցուցիչ տիպի վրա, երբ մեկ ուրիշ ժառանգված դասի օբյեկտի վրա ցույց տվող ցուցիչն ունի ընդունելի արժեք։ Այնուհետև մենք ստուգում ենք արդյո՞ք արդյունքը `nullptr` չի։ Այս ստուգումը հաճախ կարող է  հարմար ձևով տեղավորվել փոփոխականի ինիցիալիզացիայի մեջ պայմանի մեջ։








## 5.6 Պատճենում և տեղափոխում

Լռելությամբ օբյեկտներն օժտված են պատճենվելու հատկությամբ։ Սա ճշմարիտ է ինչպես օգտագործողի սահմանած տիպերի օբյեկտների համար, այնպես էլ ներդրված տիպերի համար։ Պատճենման լռելության վարքն անդամ առ անդամ պատճենումն է։ Օրինակ, օգտագործելով `complex`֊ը §4.2.1֊ից․

````c++
void test(complex z1)
{
    complex z2{z1};  // պատճենելով արժեքավորում
    complex z3;
    z3 = z2;     // պատճենելով վերագրում
}
````

Այժմ `z1`֊ը, `z2`֊ը և `z3`֊ն ունեն նույն արժեքը, քանի որ վերագրում ու արժեքավորումը պատժենել են երկու անդամներն էլ։

Երբ դաս ենք նախագծում, պետք է միշտ մտածենք այն մասին, թե ինչպես է օբյեկտը պատճենվելու։ Հաճախ պարզ կոնկրետ տիպերի համար անադամ առ անդամ պատճենումը հենց արտահայտում է պատճենման ճիշտ իմաստը։ Որոշ բարդ կոնկրետ տիպերի համար, ինչպիսին է `Vector`֊ը, անդամ առ անդամ պատճենումը պատճենման ճիշտ իմաստը չէ, իսկ վերացական տիպերի համար այն համարյա երբեք ճիշտ չէ։ (??)

### 4.6.1 Կոնտեյներների պատճենումը

Եթե դասը _ռեսուրսներ ղեկավարող_ է, այսինքն՝ երբ դասը պատասխանատվություն է կրում ցուցիչով իրեն փոխանցված օբյեկտի համար, ապա լռելությամբ սահմանված անդամ առ անդամ պատճենումը սովորաբար փորձանք է։ (??) Անդամ առ անդամ պատճենումը կարող է վնասել ռեսուրսի ղեկավարման ինվարիանտը (§3.4.2)։ Օրինակ, լռելության պատճենումը կարող է անել այնպես, որ `Vector`֊ի պատճենը հղվի սկզբնական օբյեկտի տվյալների վրա․

````c++
void bad_copy(Vector v1)
{
    Vector v2 = v1; // v1֊ի ներկայացումը պատճենել v2֊ի մեջ
    v1[0] = 2;      // հիմա v2[0]֊ն նույնպես 2 է
    v2[1] = 3;      // հիմա v1[1]֊ը նույնպես 3 է
}
````

Ենթադրելով, որ `v1`֊ն ունի չորս տարր, արդյունքը գրաֆիկլորեն կարելի է ներկայացնել հետևյալ կերպ․

> Նկար

Բարեբախտաբար, այն փաստը, որ `Vector`֊ը դեստրուկտոր ունի, խիստ հուշում է մեզ, որ լռելության անդամ առ անդամ պատճենումը սխալ է, և կոմպիլյատորը ամենաքիչը պետք է բողոքի այս օրինակից։ Պետք է սահմանել ավելի լավ պատճօենման գործողությունը։

Դասի օբյեկտի պատճենումը սահմանվում է երկու անդամներով․ _պատճենող կոնստրուկտոր_ և _պատճենող վերագրում_․

````c++
class Vector {
private:
    double∗ elem; // elem points to an array of sz doubles
    int sz;
public:
    Vector(int s); // constructor: establish invariant, acquire resources
    Vector() { delete[] elem; } // destr uctor: release resources

    Vector(const Vector& a); // copyconstr uctor
    Vector& operator=(const Vector& a); // copy assignment

    double& operator[](int i);
    const double& operator[](int i) const;

    int size() const;
}
````


