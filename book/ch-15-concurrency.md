# Զուգընթացություն

Keep it simple: as simple as possible, but no simpler.
– A. Einstein

* Ներածություն
* Խնդիրներ և `thread`-ներ
* Արգումենտների փոխանցումը
* Արդյունքների վերադարձնելը
* Տվյալների համատեղ օգտագործումը
* Պատահարներին սպասելը
* Խնդիրների հաղորդակցությունը
  - `future` և `promise`
  - `packaged_task`
  - `async()`
* Խորհուրդներ


## Ներածություն

Զուգընթացությունը՝ մի քանի խնդիրների համաժամանակյա կատարումը, լայնորեն օգտագործվում է ծրագրերի թողունակության (մի հաշվարկի համար մի քանի պրոցեսորների օգտագործմամբ) կամ արձագանքելիության (թույլ տալով ծրագրի մի մասին առաջ շարժվել, քանի դեռ մի այլ մաս սպասում է պատասխանի) լավացման համար։ Բոլոր ժամանակակից ծրագրավորման լեզուները տասլիս են դրա հնարավորությունը։ C++ լեզվի ստանդարտ գրադարանի տրամադրածը տեղափոխելի և տիպերի տեսակետից ապահով տարբերակն է այն եղանակի, որը ավելի քան 20 տարի օգտագործվել է C++ լեզվում և ապահովվում է համարյա բոլոր ժամանակակից ապարատային միջոցներով։ Ստանդարտ գրադարանի տրամադրածը առաջին հերթին նախատեսված է համակարգի մակարդակում զուգահեռության ապահովման համար, այլ ոչ թե բարձր մակարդակի զուգահեռացման բարդ մոդելների ուղղակի տրամադրման համար. վերջիններս կարող են ապահովվել որպես ստանդարտ գրադարանի հնարավորություններն օգտագործող գրադարաններ։

Ստանդարտ գրադարանը ուղղակիորեն ապահովում է նույն հասցեների տիրույթում մի քանի հոսքերի (thread) զուգահեռ կատարումը։ Դա թույլատրելու համար C++ լեզուն տրամադրում է հիշողության համապատասխան մոդել և ատոմար գործողությունների բազմություն։ Ատոմար գործողությունները փականներից ազատ (lock-free) ծրագրավորման հնարավորություն են տալիս [Dechev,2010]։ Հիշողության այս մոդելը երաշխավորում է, որ քանի դեռ ծրագրավորողը խուսափում է տվյալների մրցավազքից? (data race) (փոփոխելի տվյալներին անվերահսկելի դիմումը), ամեն ինչ աշխատում է սպասածին պես։ Այնուամենայնիվ, օգտագործողների մեծամասնությունը զուգահեռությունը կտեսնեն միայն ստանդարտ գրադարանի կամ նրա հնարավորություններով կառուցված այլ գրադարանների տերմիններով։ Այս բաժնում բերվում են ստանդարտ գրադարանի՝ զուգահեռությունն ապահովող միջոցների՝ `thread`-ներ, `mutex`-ներ, `lock()` գործողություններ, `packaged_task`-եր և `future`-ներ, հակիրճ օրինակներ։ Այդ միջոցները կառուցված են հենց օպերացիոն համակարգի տրամադրած հնարավորությունների վրա և չեն բերում արտադրողականության նվազեցման։ Դրանք ոչ էլ երաշխավորում են արտադրողականության լավացում՝ համեմատած օպերացիոն համակարգի տրամադրած միջոցներին։ (??)

Զուգահեռ կատարումը մի՛ ընդունեք որպես համադարման։ Եթե խնդիրը կարող է կատարվել հաջորդական եղանակով, ապա հաճախ ավելի պարզ ու արագ է այդպես էլ անել։

Որպես զուգահեռացման միջոցների բացահայտ օգտագործման այլընտրանք մենք հաճախ կարող ենք դիմել զուգահեռացված ալգորիթմների կիրառմանը՝ կատարման տարատեսակ մեխանիզմների օգնությամբ արտադրողականության մեծացման համար (§12.9, §14.3.1)։ (??)


## Խնդիրներ և `thread`-ներ

Այլ հաշվարկների հետ կատարվելու պոտենցիալ հնարավորություն ունեցող հաշվարկին անվանում ենք _խնդիր_ (_task_)։ _Հոսքը_ (thread) ծրագրում խնդրի համակարգային (համակարգի մակարդակի) ներկայացումն է։ Այլ խնդիրների հետ զուգահեռ կատարվող խնդիրը գործարկվում է `std::thread` (`<thread>` ֆայլից) օբյեկտ ստեղծելով և նրա արգումենտում խնդիրը տալով։ Խնդիրը ֆունկցիա է կամ ֆունկցիա օբյեկտ.

````C++
void f();                 // ֆունկցիա

struct F {                // ֆունկցիա օբյեկտ
    void operator()();   // F-ի կանչի օպերատորը (§6.3.2)
};

void user()
{
    thread t1 {f};       // f() executes in separate thread
    thread t2 {F()};     // F()() executes in separate thread

    t1.join();           // սպասել t1-ին
    t2.join();           // սպասել t2-ին
}
````

`join()`-ները երաշխավորում են, որ չենք լքի `user()`-ը, քանի դեռ հոսքերի կատարումը չի ավարտվել։ Հոսքին «միանալ» (join) նշանակում է «սպասել նրա շխատանքի ավարտին»։

Ծրագրի բոլոր հոսքերը համատեղ օգտագործում են նույն հասցեների տիրույթը։ Սրանով հոսքերը տարբերվում են պրոցեսներից, որոնք, ընդհանուր առմամբ, տվյալների ուղղակի համատեղ օգտագործում չունեն։ Քանի որ հոսքերը համատեղ են օգտագործում հասցեների նույն տիրույթը, նրանք կարող են հաղորդակցվել ընդհանուր օբյեկտների միջոցով (§15.5)։ Տյալների մրցավազքից՝ փոփոխականին անկառավարելի միաժամանակյա դիմումից, խուսափելու նպատակով այսպիսի հաղորդակցությունը սովորաբար կառավարվում է փականների (lock) կամ այլ մեխանիզմների միջոցով։

Զուգահեռ խնդիրների ծրագրավորումը կարող է բավականին բարդ լինել։ Դիրարկենք `f` (ֆունկցիա) և `F` (ֆունկցիա-օբյեկտ) խնդիրների մի հնարավոր իրականացում.

````C++
void f()
{
    cout << "Hello ";
}

struct F {
    void operator()() { cout << "Parallel World!\n"; }
};
````

Սա վատ սխալի օրինակ է. այստեղ `f`-ը և `F()`-ը երկուսն էլ `cout` օբյեկտն օգտագործում են առաց սինխրոնիզացիայի որևէ միջոցի։ Ստացված արտածումը կարող է անկանխատեսելի լինել և կարող է տարբերվել ծրագրի տարբեր կատարումների ժամանակ, քանի որ երկու խնդիրների առանձին գործողությունների կատարման կարգը սահմանված չէ։ Ծրագիրը կարող է արտածել շատ «տարօրինակ» արդյունք.

````
PaHerallllel o World!
````

Միայն ստադարտի որոշակի երաշխիքներն են մեզ զերծ պահում `ostream`-ի սահմանման շրջանակներում տվյալների մրցավազքից, որը կարող է բերել ծրագրի վթարային ավարտի։

Զուգահեռ կատարվող ծրագրում խնդիրներ սահմաելիս մեր նպատակն է այդ խնդիրները պահել լիովին անկախ, բացառությամբ այն դեպքերի, երբ նրանք հաղորդակցվում են պարզ ու ակնհայտ եղանակով։ զուգահեռ կատարվող խնդրի մասին պաատկերացում կազմելու ամենապարզ տարբերակը ֆունկցիան է, որը պետք է կատարվի ին կանչողին զուգահեռ։ (?) Դա համար պարզապես պետք է փոխանցենք արգումենտներ, հետ ստանանք արդյունքը և համոզվենք, որ ընդհանուր օգտագործման տվյալներ չկան (չկա տվյալների մրցավազք):


## Արգումենտների փոխանցումը

Իր աշխատանքի համար խնդիրը սովորապար կարիք ունի տվյալների։ Տվյալները (կամ դրանց ցուցիչներն ու հղումները) կարող ենք պարզապես փոխանցել որպես արգումենտներ։ Դիցուք.

````C++
void f(vector<double>& v);    // function do something with v

struct F {                    // function object: do something with v
    vector<double>& v;
    F(vector<double>& vv) :v{vv} { }
    void operator()();       // application operator; §6.3.2
};

int main()
{
    vector<double> some_vec {1,2,3,4,5,6,7,8,9};
    vector<double> vec2 {10,11,12,13,14};

    thread t1 {f,ref(some_vec)};   // f(some_vec) executes in a separate thread
    thread t2 {F{vec2}};           // F(vec2)() executes in a separate thread

    t1.join();
    t2.join();
}
````

Ակնհայտ է, որ `F{vec2}`-ը արգումենտում տրված վեկտորի հղումը պահում է `F`-ի մեջ։ Այժմ `F`-ը կարող է օգտագործել այդ վեկտորը, և հույս ունենանք, որ որևէ այլ խնդիր չի դումում `vec2`-ին, քանի դեռ `F`-ը կատարվում է։ `vec2`-ը որպես արժեք փոխանցելով կբացառենք այդ վտանգը։

`{f,ref(some_vec)}` տեսքի ինիցիալիզացիան օգտագործում է `thread` կաղապարի վարիադիկ կոնստրուկտորը, որը կարող է ընդունել արգումենտների կամայական հաջորդականություն (§7.4)։ `ref()`-ը տիպի ֆունկցիա է `<functional>`-ից, որը ցավոք անհրաժեշտ է, որպեսզի վարիադիկ կաղապարը `some_vec`-ը համարի հղում, այլ ոչ թե օբյեկտ։ Առանց այս `ref()`-ի `some_vec`-ը կփոխանցվի որպես արժեք։ Կոմպիլյատորը ստուգում է, որ առաջին արգումենտը կարող է կանչվել հաջորդիվ տրված արգումենտներով և կառուցում է համապատասխան ֆունկցիա-օբյեկտը՝ հոսքին փոխանցելու համար։ Այսինքն, եթե `F::operator()()`-ը և `f()`-ը իրականացնում են նույն ալգորիթմը, ապա երկու խնդիրների կատարումը համարյա համարժեք է. երկու դեպքում էլ `thread`-ի կատարման համար ստեղծվում է ֆունկցիա-օբյեկտ։


## Արդյունքների վերադարձնելը

§15.3-ի օրինակում ես արգումենտները փոխանցեցի որպես ոչ-`const` հղում։ Այդպես անում եմ միայն երբ ուզում եմ, որ խնդիրը կարողանա փոփոխել հղվող արժեքը (§1.7)։ Սա  արժեք վերադարձնելու մի քիչ կոպիտ, բայց տարածված եղանակ է։ Ավելի պակաս մշուշոտ հնարքն է՝ մուտքային տվյալները փոխանցել `const` հղումներով, և առանձին արգումենտով էլ փոխանցել այն տեղը, որտեղ պետք է գրվի վերադարձվող արժեքը.

````C++
void f(const vector<double>& v, double* res);    // take input from v; place result in *res

class F {
public:
    F(const vector<double>& vv, double* p) :v{vv}, res{p} { }
    void operator()();          // place result in *res
private:
    const vector<double>& v;    // source of input
    double* res;                // target for output
};

double g(const vector<double>&); // use return value

void user(vector<double>& vec1, vector<double> vec2, vector<double> vec3)
{
    double res1;
    double res2;
    double res3;

    thread t1 {f,cref(vec1),&res1};        // f(vec1,&res1) executes in a separate thread
    thread t2 {F{vec2,&res2}};             // F{vec2,&res2}() executes in a separate thread
    thread t3 {[&](){res3 = g(vec3);}};    // capture local variables by reference

    t1.join();
    t2.join();
    t3.join();

    cout << res1 << ' ' << res2 << ' ' << res3 << '\n';
}
````

Աշխատում է և այս եղանակն էլ բավականին տարածված է, սակայն հղման միջոցով արժեք վերադարձնելը ես բավականաչափ էլեգանտ չեմ համարում, այդ պատճառով էլ այս թեմային նորից կանդրադառնամ §15.7.1-ում։

## Տվյալների համատեղ օգտագործումը

Երբեմն անհրաժեշտ է լինում, որ խնդիրները տվյալները համատեղ օգտագործեն։ Այդ դեպքում տվյալներին հասանելիությունը պետք է համաձայնեցնել այնպես, որ ժամանակի որևէ պահի միայն մեկ խնդիր կարողանա օգտագործել դրանք։ Փորձառու ծրագրավորողները կասեն որ սա շատ պարզեցված է (այսինքն, ոչ մի վտանգ չկա, երբ մի քանի խնդիրներ միաժամանակ կարդում են անփոփոխելի տվյալները), բայց, այնուամենայնիվ, դիտարկենք, թե ինչպես կարելի է երաշխավորել, որ ժամանակի տվյալ պահին տվյալների բազմությանը դիմի առավելագույնը մեկ խնդիր։ (??)

Այս խնդրի լուծման հիմնարար տարրը `mutex`-ն է՝ «mutual exclusion object» — «փոխադարձ բացառման օբյեկտը»։ `thread`-ը `mutex`-ին տիրանում է `lock()` գործողության միջոցով.

````C++
mutex m; // controlling mutex
int sh;  // shared data

void f()
{
    scoped_lock lck {m};        // acquire mutex
    sh += 7;                    // manipulate shared data
}    // release mutex implicitly
````

`lck`-ի տիպը արտածվում է որպես `scoped_lock<mutex>` (§6.2.3)։ `scoped_lock`-ի կոնստրուկտորը տիրանում է `mutex`-ին (`m.lock()` կանչով)։ Եթե մի այլ հոսք արդեն տիրացել է մյուտեքսին, ապա այս հոսքը սպասում է (“blocks”) այնքան, մինչև մյուս հոսքը վերջացնի տվյալներին դիմելու իր գործողությունը։ Հենց որ հոսքը վերջացնում է ընդհանուր օգտագործվող տվյալների հետ իր աշխատանքը, `scoped_lock`-ը ազատում է `mutex`-ը (`m.unlock()` կանչով)։ Երբ մյուտեքսն ազատվում է, նրան սպասող հոսքերը շարունակում են իրենց աշխատանքը՝ «արթնանում են»։ Փոխադարձ բացառման և փականների մեխանիզմները սահմանված են `<mutex>`-ում։

Ուշադրություն դարձրեք RAII սկզբունքի կիրառմանը (§5.3)։ Ռեսուրսների նկարագրիչների օգտագործումը, ինչպիսիք են `scoped_lock`-ը և `unique_lock`-ը (§15.6), ավելի պարզ ու ապահով է, քան `mutex`-ի ուղղակի locking and unlocking։ (??)

Համատեղ օգտագործվող տվյալների և `mutex`-ի կապը պայմանական է. ծրագրավորողը պարզապես պարտավոր է իմանալ, թե որ `mutex`-ը որ տվյալների համար է նախատեսված։ Ակնհայտ է, որ սա հղի է սխալներով, և նույնպես ակնհայտ է, որ մենք փորձելու ենք համապատասխանությունը պարզաբանել լեզվի զանազան միջոցների կիրառմամբ։ Օրինակ.

````C++
class Record {
public:
    mutex rm;
    // ...
};
````

Պետք չէ հանճար լինել՝ գլխի ընկնելու համար, որ `rec` `Record`-ի այլ մասերին դիմելու համար պետք է նախ տիրանալ `rec.rm`-ին, չնայած ընթերցողին օգտակար կլինեին նաև ավելի լավ ընտրված անունը կամ մեկնաբանությունը։ (??)

Քիչ չեն այն դեպքերը, երբ ինչ-որ գործողության համար միաժամանակ հասանելիություն է պետք մի քանի ռեսուրսների։ Սա կարող է բերել փակուղու? (deadlock)։ Օրինակ, եթե `thread1`-ը տիրանում է `mutex1`-ին, ապա փորձում է տիրանալ `mutex2`-ին, իսկ `thread2`-ը տիրանում է `mutex2`-ին, ապա փորձում է տիրանալ `mutex1`-ին. արդյունքում խնդիրը երբեք առաջ չի գնա։ (?) `scoped_lock`-ը հնարավորություն է տալիս միաժամանակ տիրանալ մի քանի փականների.

````C++
void f()
{
    scoped_lock lck {mutex1,mutex2,mutex3};   // acquire all three locks
    // ... manipulate shared data ...
}// implicitly release all mutexes
````

Այս `scoped_lock`-ը թույլ կտա ֆունկցիայի աշխատանքը շարունակել միայն իր արգումենտներում տրված բոլոր մյութեքսներին տիրանալուց հետո and will never block (“go to sleep”) while holding a mutex. `scoped_lock`-ի դեստրուկտորը երաշխավորում է, որ երբ հասք լքի իր տիրույթը, ապա `mutex`-ները կազատվեն։

Համատեղ օգտագործվող տվյալների միջոցով հաղորդակցվելը ցածր մակարդակի հնարք է։ Մասնավորապես, ծրագրավորողը պետք է մտածի ճանապարհներ, որպեսզի հետևի, թե ինչ աշխատանք է արվել կամ մնացել տարբեր խնդիրներում։ (?) Այդ պատճառով էլ համատեղ օգտագործվող տվյալների օգտագործումը զիջում է կանչի և վերադարձի գաղափարին։ (?) Մյուս կողմից էլ, որոշ մարդիկ համոզված են, որ համատեղ օգտագործումը պիտի ավելի արդյունավետ լինի, քան արգումենտների պատճենումն ու արժեք վերադարձնելը։ Թերևս կարող է այդպես լինել՝ երբ ներգրավված են տվյալների մեծ կտորներ, սակայն locking and unlocking համեմատաբար թանկ գործողություններ են։ Մյուս կողմից էլ՝ ժամանակակից մեքենաները շատ հաջող են տվյալների պատճենման գործում, հատկապես կոմպակտ տվյալների, ինչպիսիք են `vector`-ի տարրերը։ Այսպիսով, հոսքերի հաղորդակցության համար մի ընտրեք համատեղ օգտագործվող տվյալները՝ պատճառաբանելով «արդյունավետությունը», առանց կշռադատելու և ցանկալի է ոչ առանց չափումների։ (?!)

Սովորական `mutex`-ը թույլ է տալիս, որ տվյալը միաժամանակ հասանելի լինի միայն մեկ հասքի։ Տվյալների համատեղ օգտագործման տարածված եղանակներից մեկը շատ կարդացողներ և մեկ գրող ունենալն է։ Այս «կարդացող-գրող կողպեքի» դաղափարը տրամադրում է `share_mutex`-ը։ Կարդացողը մյութեքսին կտիրանա՝ թույլատրելով համատեղ օգտագործումը այնպես, որ այլ կարդացողներ նույնպես տվյալներին հասանելիություն ունենան, մինչդեռ գրողը կպահանջի տվյալների բացառիկ հասանելիություն։ Օրինակ.

````C++
shared_mutex mx;          // mutex-ը կարող է համատեղ օգտագործվել

void reader()
{
    shared_lock lck {mx};  // ցանկալի է այլոց հետ համատեղ օգտագործումը
    // ... կարդալ ...
}

void writer()
{
    unique_lock lck {mx};   // պահանջվում է բացառիկ, միանձնյա հասանելիություն
    // ... գրել ...
}
````


## Պատահարներին սպասելը

Երբեմն հասքը պետք է սպասի ինչ-որ արտաքին պատահարի, ինչպիսին է մեկ այլ հոսքի՝ աշխատանք ավարտելը, կամ որոշակի ժամանակ լրանալը։ Պարզագույն «պատահարը» ժամանակի լրանալն է։ `<chrono`-ում սահմանված հնարավորություններն օգտագործելով կարող եմ գրել.

````C++
using namespace std::chrono;    // տես §13.7

auto t0 = high_resolution_clock::now();
this_thread::sleep_for(milliseconds{20});
auto t1 = high_resolution_clock::now();

cout << duration_cast<nanoseconds>(t1−t0).count() << " nanoseconds passed\n";
````

Ուշադրություն դարձրեք, որ ես նույնիսկ նոր հոսք չգործարկեցի. լռելությամբ `this_thread`-ը հղվում է մեկ ու միակ հոսքի։ (?)

Ես `duration_cast`-ն օգտագործել եմ ինձ հարկավոր նանովարկյանների ձևափոխելու համար։

Արտաքին պատահարների օգտագործմամբ հաղորդակցվելու հնարավորություն է տալիս `<condition_variable>`-ում սահմանված `condition_variable`-ը։ Սա մի մեխանիզմ է, որ մի հասքին թույլ է տալիս սպասել մի այլ հասքի աշխատանքին։ (?) մասնավորապես, այն հոսքին հնարավորություն է տալիս սպասել մեկ այլ հասքի կատարման արդյունքում տեղի ունեցող ինչ-որ _պայմանի_ (հաճախ կոչվում է _պատահար_)։ (??)

Պայմանական փոփոխականների օգտագործումը, որն ապահովում է տվյալների համատեղ օգտագործման շատ գեղեցիկ ու արդյունավետ եղանակներ, կարող է նաև բավականին խրթին լինել։ Դիտարկենք հերթի միջոցով հաղորդագրություններ փոխանակող երկու հասքերի դասական օրինակը։ Պարզության նպատակով հերթը (`queue`) և այդ հերթի նկատմամբ մրցավազքի վիճակից խուսափելն ապահովող միջոցները հայտարարել եմ գլոբալ՝ մատակարարողի (producer) և սպառողի (consumer) համար.

````C++
class Message {    // object to be communicated
    // ...
};

queue<Message> mqueue;         // the queue of messages
condition_variable mcond;      // the variable communicating events
mutex mmutex;                  // for synchronizing access to mcond
````

`queue`, `condition_variable` և `mutex` տիպերը ստանդարտ գրադարանից են։

Սպառողի ֆունկցիան՝ `consumer()`, կարդում և մշակում է `Message`-ները.

````C++
void consumer()
{
    while(true) {
        unique_lock lck {mmutex};          // acquire mmutex
        mcond.wait(lck,[] { return !mqueue.empty(); });   // release lck and wait;

        // re-acquire lck upon wakeup
        // don't wake up unless mqueue is non-empty
        auto m = mqueue.front();           // get the message
        mqueue.pop();
        lck.unlock();                      // release lck
        // ... process m ...
     }
}
````

Այստեղ ես `mqueue`-ի և `condition_variable`-ի գործողությունները հատուկ պաշտպանում եմ `mutex`-ի `unique_lock`-ով՝։ `condition_variable`-ի սպասելը բաց է թողնում իր արգումենտ փականը քանի դեռ սպասումը չի ավարտվել (քանի դեռ հերփը դատարկ չէ), ապա նորից զբաղեցնում է այն։ Պայմանի բացահայտ ստուգումը, այստեղ `!mqueue.empty()`, պաշտպանում է protects against waking up just to find that some other task has “gotten there first” so that the condition no longer holds.

`scoped_lock`-ի փոխարեն `unique_lock`-ն օգտագործել եմ երկու պատճառով.

* Պետք է կարողանանք փականը փոխանցել `condition_variable`-ի `wait()`-ին։ `scoped_lock`-ը չի կարող պատճենվել, իսկ `unique_lock`-ը կարող է։
* Ուզում ենք, մինչև հաղորդագրության մշակելը, բաց թողնել պայմանական փոփոխականը պաշտպանող `mutex`-ը։ `unique_lock`-ը գործողություններ է առաջարկում սինխրոնիզացիայի ցածր մակարդակի կառավարման համար, ինչպիսիք են `lock()`-ը և `unlock()`-ը։

Մյուս կողմից էլ՝ `unique_lock`-ը կարող է օգտագործել միայն մեկ `mutex`։

Համապատասխան արտադրողն ունի հետևյալ տեսքը.

````C++
void producer()
{
     while(true) {
          Message m;
          // ... fill the message ...
          scoped_lock lck {mmutex};      // պաշտպանել գործողությունը
          mqueue.push(m);
          mcond.notify_one();            // notify
     }                                   // release lock (at end of scope)
}
````

## Խնդիրների հաղորդակցությունը

Ստանդարտ գրադարանն առաջարկում է մի քանի միջոցներ, որոնք ծրագրավորողին թույլ են տալիս աշխատել խնդիրների (work to potentially be done concurrently) սկզբունքային մակարդակում՝ հոսքերի ու փականների ցածր մակարդակի գործողությունների փոխարեն.

* `future` և `promise` — առանձին հոսքում գործարկված խնդրից արժեք վերադարձնելու համար,
* `packaged_task` — խնդիրը գործարկելու և արժեք վերադարձնելու միջոցները միացնելու համար,
* `async()` — խնդիրը ֆունկցիայի կանչին նման եղանակով գործարկելու համար։

Այս հնարավորությւունները սահմանված են `<future>`-ում։


### `future` և `promise`

`future`-ի և `promise`-ի կարևոր հատկությունն այն է, որ նրանք հնարավորություն են տալիս, առանց փականների բացահայտ օգտագործման, արժեքներ փոխանցել երկու խնդիրների միջև. փոխանցումը արդյունավետ իրականացնում է «համակարգը»։ Հիմնական գաղափարը պարզ է. երբ մի խնդիրը ուզում է արժեք փոխանցել մյուսին, այն արժեքը գրում է `promise`-ի մեջ։ Ինչ-որ կերպ իրականացումն ապահովում է, որ այդ արժեքը հայտնվի համապատասխան `future`-ի մեջ, որից այն կարելի է կարդալ (սովորաբար խնդիրը գործարկողի կողմից)։ Դա կարող ենք գրաֆիկորեն ներկայացնել այսպես.

Եթե ունենք `future<X>` տիպի `fx`-ը, ապա `get()` ֆունկցիայով կարող ենք նրանից վերցնել `X` տիպի արժեք.

````C++
X v = fx.get();  // եթե անհրաժեշտ է՝ սպասել մինչև արժեքը հաշվարկվի
````

Եթե արժեքը դեռ այդտեղ չէ, մեր հոսքը կանգ կառնի {blocked} մինչև նրա հայտնվելը։ (?) Եթե արժեքը չի կարող հաշվարկվել, `get()`-ը կարող է բացառություն դուրս նետել (համակարգից կամ այն խնդրից, որից փորձում էին ստանալ արժեքը)։

`promise`-ի գլխավոր նպատակը `future`-ի `get()`-ին համապատասխան պարզ «put» գործողությունների ապահովումն է (`set_value()` և `set_exception()`)։ «future» և «promise» անունները պատմական են. խնդրում եմ, մի՛ մեղադրեք կամ գովեք ինձ։ Դրանք բառախաղերի ևս մի հարուստ աղբյուր են։ (??)

Եթե ունեք `promise` և ձեզ պետք է `X` տիպի արդյունքն ուղարկել `future`-ին, կարող եք անել երկու եղանակով. փոխանցել արժեք կամ փոխանցել բացառություն։ Օրինակ.

````C++
void f(promise<X>& px) // a task: place the result in px
{
    // ...
    try{
        X res;
        // ... compute a value for res ...
        px.set_value(res);
    }
    catch (...) {      // oops: couldn't compute res
        px.set_exception(current_exception());     // pass the exception to the future's thread
    }
}
````

`current_exception()`-ը հղվում է որսված բացառությանը։

To deal with an exception transmitted through a future, the caller of get() must be prepared to catch it somewhere. For example:

````C++
void g(future<X>& fx)       // a task: get the result from fx
{
    // ...
    try{
        X v = fx.get();  // if necessary, wait for the value to get computed
        // ... use v ...
    }
    catch (...) {         // oops: someone couldn't compute v
        // ... handle error ...
    }
}
````

If the error doesn’t need to be handled by g() itself, the code reduces to the minimal:

````C++
void g(future<X>& fx)        // a task: get the result from fx
{
    // ...
    X v = fx.get();  // if necessary, wait for the value to get computed
    // ... use v ...
}
````
